<!DOCTYPE html>
<html lang="sv">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProChorder 9.8</title>
    <style>
        :root {
            --chord-btn-width: 65px;
            --chord-btn-height: 32px;
            --bg: #f4f5f7;
            --surface: #ffffff;
            --text-color: #172b4d;
            --primary: #1951a5;
            --border: #dfe1e6;
            --shadow: 0 4px 8px -2px rgba(9, 30, 66, 0.25), 0 0 1px rgba(9, 30, 66, 0.31);
            --chord-color: var(--primary);
            --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            --success-bg: #376e43;
            --danger-bg: #8d323b;
            --button-text-light: #ffffff;
            --primary-bg-hover: rgba(0, 82, 204, 0.1);
            --section-marker-color: var(--danger-bg);
            --menu-width: 320px;
        }

        body.dark-mode {
            --bg: #1d2125;
            --surface: #282d33;
            --text-color: #c1c9d3;
            --primary: #4c9aff;
            --border: #454c54;
            --chord-color: #ffcb47;
            --primary-bg-hover: rgba(76, 154, 255, 0.15);
            --section-marker-color: #FFFFFF;
        }

        body.dark-mode #editor a {
            color: var(--chord-color);
            text-decoration: underline;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background-color: var(--bg);
            color: var(--text-color);
            margin: 0;
            padding: 1em;
            padding-top: 70px;
            transition: background-color 0.3s, color 0.3s;
            overflow-x: hidden;
        }

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1em;
            padding: 10px 1em;
            background-color: var(--bg);
            z-index: 100;
            border-bottom: 1px solid var(--border);
        }

        .top-bar-left,
        /*Knapper √∂verst*/
        .top-bar-right {
            display: flex;
            align-items: center;
            gap: 0.5em;
        }

        .top-bar-left {
            flex-grow: 1;
            min-width: 0;
        }

        #project-list {
            flex-grow: 1;
            /* Till√•t den att v√§xa */
            min-width: 140px;
            /* Men aldrig bli mindre √§n s√• h√§r */
            max-width: 450px;
            /* Och aldrig bli st√∂rre √§n s√• h√§r */
        }

        .top-bar select,
        .top-bar button {
            border: 1px solid var(--border);
            background-color: var(--surface);
            color: var(--text-color);
            border-radius: 8px;
            box-shadow: 0 1px 1px rgba(9, 30, 66, 0.25), 0 0 1px rgba(9, 30, 66, 0.31);
            font-size: 1em;
            height: 33px;
            box-sizing: border-box;
        }

        .top-bar button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 33px;
            padding: 0;
            font-size: 1.2em;
            flex-shrink: 0;
            cursor: pointer;
            font-weight: 700;
        }

        .top-bar select {
            padding: 0 0.75em;
        }

        #hamburger-btn {
            font-size: 24px;
            font-weight: normal;
        }

        #btn-toggle-dark-mode {
            font-size: 1.5em;
        }

        #side-menu {
            position: fixed;
            top: 0;
            right: 0;
            height: 100%;
            width: var(--menu-width);
            max-width: 90%;
            background-color: var(--surface);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            transform: translateX(100%);
            transition: transform 0.3s ease-in-out;
            z-index: 1001;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1em;
            padding: 1.5em;
        }

        #side-menu:not(.is-closed) {
            transform: translateX(0);
        }

        #menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(9, 30, 66, 0.5);
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.3s ease-in-out;
        }

        #menu-overlay.is-closed {
            opacity: 0;
            pointer-events: none;
        }

        .container {
            max-width: 1280px;
            margin: 0 auto;
        }

        .app-layout {
            display: flex;
            flex-direction: column;
            gap: 1em;
        }

        .sidebar-group {
            width: 100%;
            border: 1px solid var(--border);
            border-radius: 8px;
        }

        .sidebar-group-label {
            position: relative;
            cursor: pointer;
            padding: 0.8em;
            user-select: none;
            font-weight: 700;
            display: block;
        }

        .sidebar-group-label::after {
            content: '‚Ä∫';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%) rotate(0deg);
            transition: transform 0.3s ease;
            font-size: 1.5em;
        }

        .sidebar-group-label.is-open::after {
            transform: translateY(-50%) rotate(90deg);
        }

        .sidebar-group-content {
            overflow: hidden;
            max-height: 500px;
            transition: max-height 0.4s ease-in-out, padding 0.3s ease-out;
            padding: 0 1em 1em 1em;
        }

        .sidebar-group-content.is-collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            visibility: hidden;
        }

        .sidebar-controls {
            display: flex;
            flex-direction: column;
            gap: 0.8em;
            padding-top: 0;
        }

        .sidebar-controls.horizontal {
            flex-direction: row;
            align-items: center;
            gap: 0.4em;
        }

        .sidebar-controls span {
            font-size: 0.8em;
            margin-right: 0.2em;
            white-space: nowrap;
        }

        #side-menu button,
        #side-menu select,
        #side-menu input {
            font-family: var(--font-sans);
            font-weight: 600;
            font-size: 0.85em;
            height: 33px;
            background-color: var(--bg);
            color: var(--text-color);
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            padding: 0 0.7em;
            box-sizing: border-box;
            width: 70%;
        }

        #side-menu #song-title {
            font-weight: 700;
        }

        .sidebar-controls.horizontal>* {
            flex: 1;
        }

        #side-menu button:hover {
            transform: translateY(1px);
            border-color: var(--primary);
        }

        #side-menu button.btn-primary {
            background-color: var(--primary);
            color: var(--button-text-light);
        }

        #side-menu button.btn-success {
            background-color: var(--success-bg);
            color: var(--button-text-light);
        }

        #side-menu button.btn-danger {
            background-color: var(--danger-bg);
            color: var(--button-text-light);
        }

        #side-menu input[type="range"] {
            height: auto;
        }

        .main-content {
            flex-basis: 0;
            flex-grow: 999;
            min-width: 60%;
            display: flex;
            flex-direction: column;
            gap: 1em;
        }

        #editor {
            background-color: var(--surface);
            border: 1px solid var(--border);
            padding: 0.5em;
            border-radius: 8px;
            box-shadow: 0 1px 1px rgba(9, 30, 66, 0.25), 0 0 1px rgba(9, 30, 66, 0.31);
            height: calc(100vh - 90px);
            font-family: var(--font-sans);
            line-height: 1.9;
            outline: none;
            font-size: 16px;
            overflow-y: scroll;
            clear: both;
            width: 100%;
        }

        #editor a {
            cursor: pointer;
        }

        #editor>div:not(:has(.section-marker)) {
            line-height: 2.5;
        }

        #editor:focus-within {
            border-color: var(--primary);
        }

        #editor>div {
            position: relative;
        }

        #editor .chord {
            display: inline-block;
            position: relative;
            user-select: none;
            cursor: default;
            vertical-align: middle;
            top: -1.7em;
            /* ................Ackord avst√•nd till text..........*/
            height: 0;
            width: 0;
            padding: 0;
            margin: 0;
            z-index: 5;
        }

        #editor .chord:hover {
            background-color: var(--primary-bg-hover);
            z-index: 10;
        }

        #editor .chord-text {
            position: absolute;
            left: 0;
            display: inline-block;
            font-family: var(--font-sans);
            font-weight: 600;
            font-size: 0.85em;
            color: var(--chord-color);
            line-height: 1.2;
            min-width: 1ch;
            outline: none;
            padding: 0.1em 0.4em;
            border-radius: 3px;
            white-space: nowrap;
        }

        #editor .chord-handle {
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 10px;
            background-color: var(--primary);
            border-radius: 3px;
            cursor: grab;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
        }

        #editor .chord:hover .chord-handle {
            opacity: 1;
            pointer-events: auto;
        }

        #editor .section-marker {
            display: block;
            margin-bottom: 0.25em;
            line-height: 2.5;
            font-weight: 700;
            font-size: 1.1em;
            color: var(--text-color);
            background-color: transparent;
            padding: 0;
            user-select: none;
        }

        #editor.text-mode .chord-handle {
            display: none !important;
        }

        #editor.text-mode .chord {
            opacity: 0.6;
        }

        body.scroll-mode-active #editor {
            caret-color: transparent;
            border-color: transparent;
            box-shadow: none;
        }

        .custom-dialog-overlay,
        #scroll-controls {
            z-index: 2000;
        }

        .custom-dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .custom-dialog-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .custom-dialog-box {
            background-color: var(--surface);
            color: var(--text-color);
            padding: 2em;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-align: center;
            min-width: 300px;
            max-width: 90%;
        }

        .custom-dialog-box .dialog-buttons {
            display: flex;
            gap: 1em;
            justify-content: center;
            margin-top: 1.5em;
        }

        .custom-dialog-box button {
            min-width: 100px;
            height: 38px;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
        }

        .custom-dialog-box button.btn-primary {
            background-color: var(--primary);
            color: var(--button-text-light);
        }

        /* Ny stil f√∂r siffer-rutorna i live-l√§get */
        #scroll-controls input[type="number"] {
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--button-text-light);
            border-radius: 8px;
            height: 38px;
            width: 60px;
            font-size: 1.2em;
            font-weight: 700;
            text-align: center;
            -moz-appearance: textfield;
            /* D√∂ljer pilarna i Firefox */
        }

        /* D√∂ljer upp/ner-pilarna i Chrome, Safari, etc. */
        #scroll-controls input[type="number"]::-webkit-outer-spin-button,
        #scroll-controls input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        #drop-indicator {
            position: absolute;
            width: 2px;
            height: 1.8em;
            background-color: var(--primary);
            display: none;
            pointer-events: none;
            z-index: 9999;
        }

        body.is-dragging * {
            cursor: none !important;
        }

        #scroll-controls {
            /* Positionering och grundl√§ggande layout */
            display: none;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            padding: 0.8em 1em;
            z-index: 2000;

            /* Den nya "glas-stilen" */
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(8px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);

            /* Grid-layout f√∂r inneh√•llet */
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto auto;
            align-items: center;
            gap: .75em 1em;
        }

        #scroll-btn-play-pause,
        #scroll-btn-exit {
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--button-text-light);
            border-radius: 8px;
            height: 38px;
            width: 60px;
            font-size: 1.2em;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        #scroll-btn-play-pause:hover,
        #scroll-btn-exit:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        body.scroll-mode-active #scroll-controls {
            display: grid;
        }

        #scroll-controls .speed-control {
            grid-column: 1 / -1;
            grid-row: 1;
            display: flex;
            align-items: center;
            gap: .5em;
        }

        #scroll-btn-play-pause {
            grid-column: 1;
            grid-row: 2;
        }

        #scroll-controls .duration-control {
            grid-column: 2;
            grid-row: 2;
            justify-self: center;
            display: flex;
            align-items: center;
            gap: .5em;
        }

        #scroll-btn-exit {
            grid-column: -3;
            grid-row: 2;
            /*justify-self: flex-end; L√§gger stopp-knapp till h√∂ger*/
        }

        body.scroll-mode-active #editor {
            caret-color: transparent;
            border-color: transparent;
            box-shadow: none;
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, var(--chord-btn-width));
            gap: 6px;
            justify-content: center;
            margin-top: 1em;
        }

        .chord-grid button {
            all: unset;
            display: flex;
            align-items: center;
            justify-content: center;
            width: var(--chord-btn-width);
            height: var(--chord-btn-height);
            box-sizing: border-box;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: var(--font-sans);
            font-size: 0.85em;
            font-weight: 600;
            background-color: var(--bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }


        .chord-grid button:hover {
            background-color: var(--primary-bg-hover);
            border-color: var(--primary);
        }

        .chord-grid button.active {
            background-color: var(--primary);
            color: var(--button-text-light);
            border-color: var(--primary);
        }

        .hidden-file {
            display: none;
        }

        #floating-live-btn {
            position: fixed;
            bottom: 24px;
            right: 20px;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background-color: var(--primary);
            color: var(--button-text-light);
            border: none;
            font-size: 0.8em;
            /* G√∂r play-symbolen lite st√∂rre */
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow);
            z-index: 100;
            /* Ser till att den ligger ovanp√• texten */
            transition: transform 0.2s ease-out, opacity 0.3s ease;
        }

        #floating-live-btn:hover {
            transform: scale(1.05);
            /* En trevlig effekt n√§r man hovrar */
        }

        /* D√∂lj knappen n√§r scroll-l√§get redan √§r aktivt */
        body.scroll-mode-active #floating-live-btn {
            opacity: 0;
            pointer-events: none;
            /* G√∂r den oklickbar n√§r den √§r osynlig */
            transform: scale(0.8);
        }
    </style>
</head>

<body>
    <div class="top-bar">
        <div class="top-bar-left">
            <select id="project-list"></select>
            <button id="btn-new-project" class="btn-primary" title="New Project">+</button>
        </div>
        <div class="top-bar-right">
            <button id="main-toggle-edit-mode-btn" title="V√§xla Redigeringsl√§ge">A</button>
            <button id="btn-show-help" title="Hj√§lp & HOW TO">?</button> <button id="btn-toggle-dark-mode"
                title="V√§xla ljust/m√∂rkt l√§ge">üåô</button>
            <button id="hamburger-btn">‚ò∞</button>
        </div>
    </div>

    <div id="menu-overlay" class="is-closed"></div>

    <nav id="side-menu" class="is-closed">
        <input type="text" id="song-title" placeholder="L√•ttitel">
        <input type="text" id="song-author" placeholder="Artist / L√•tskrivare">
        <button id="btn-toggle-scroll-mode" class="btn-primary">LIVE!</button>

        <div class="sidebar-group">
            <span class="sidebar-group-label" id="edit-mode-label">Redigera</span>
            <div class="sidebar-group-content is-collapsed">
                <div class="sidebar-controls vertical">
                    <button id="btn-toggle-edit-mode" title="V√§xla mellan text- och ackordl√§ge">Byt l√§ge</button>
                    <div class="sidebar-controls horizontal">
                        <button id="btn-transpose-up">+1</button>
                        <button id="btn-transpose-down">-1</button>
                    </div>
                    <div class="sidebar-controls horizontal">
                        <span>Font size</span>
                        <input type="range" id="font-size-slider" min="12" max="32" value="16">
                    </div>
                </div>
            </div>
        </div>
        <div class="sidebar-group">
            <span class="sidebar-group-label">Sections</span>
            <div class="sidebar-group-content is-collapsed">
                <div class="sidebar-controls horizontal">
                    <select id="section-type-select-menu"></select>
                    <button id="btn-insert-section">Insert</button>
                </div>
            </div>
        </div>
        <div class="sidebar-group">
            <span class="sidebar-group-label">Project</span>
            <div class="sidebar-group-content is-collapsed">
                <div class="sidebar-controls vertical">
                    <button id="btn-save-project" class="btn-success">Save</button>
                    <button id="btn-delete-project" class="btn-danger">Remove</button>
                    <button id="btn-delete-all-projects" class="btn-danger">Erase all</button>
                </div>
            </div>
        </div>
        <div class="sidebar-group">
            <span class="sidebar-group-label">Import/Export</span>
            <div class="sidebar-group-content is-collapsed">
                <div class="sidebar-controls vertical" style="gap: 0.5em;">
                    <div class="sidebar-controls horizontal">
                        <button id="btn-export-pdf">PDF</button>
                        <button id="btn-export-txt">TXT</button>
                        <button id="btn-export-zip">ZIP</button>
                    </div>
                    <div class="sidebar-controls horizontal">
                        <button id="btn-export-json">Song->JSON</button>
                        <button id="btn-export-all-json">All->JSON</button>
                    </div>
                    <div class="sidebar-controls horizontal">
                        <button id="btn-import-json">Imp.->JSON</button>
                        <button id="btn-import-url" class="btn-primary">Import URL</button>
                    </div>
                    <input type="file" id="file-import" accept="application/json" class="hidden-file">
                </div>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="app-layout">
            <main class="main-content">
                <div id="editor" contenteditable="true" spellcheck="false"></div>
            </main>
        </div>
    </div>

    <div id="scroll-controls">
        <button id="scroll-btn-play-pause">‚ñ∂</button>
        <div class="speed-control">
            <span>Slow</span>
            <input type="range" id="scroll-speed-slider" min="0" max="100" value="20">
            <span>Fast</span>
        </div>
        <div class="duration-control">
            <label></label> <!--Lable Time-->
            <input type="number" id="scroll-duration-minutes" min="0" max="60" value="4">
            <span>m</span>
            <input type="number" id="scroll-duration-seconds" min="0" max="59" step="5" value="0">
            <span>s</span>
        </div>
        <button id="scroll-btn-exit">Exit</button>
    </div>

    <div id="custom-alert" class="custom-dialog-overlay">
        <div class="custom-dialog-box">
            <p id="custom-alert-message"></p>
            <div class="dialog-buttons"><button id="custom-alert-ok" class="btn-primary">OK</button></div>
        </div>
    </div>
    <div id="custom-confirm" class="custom-dialog-overlay">
        <div class="custom-dialog-box">
            <p id="custom-confirm-message"></p>
            <div class="dialog-buttons">
                <button id="custom-confirm-cancel">Cancel</button>
                <button id="custom-confirm-ok" class="btn-danger">OK</button>
            </div>
        </div>
    </div>

    <div id="chord-editor-modal" class="custom-dialog-overlay">
        <div class="custom-dialog-box" style="min-width: 400px;">
            <h3 id="modal-chord-target">Select Chord</h3>
            <div id="modal-chord-builder">
                <div id="modal-root-notes" class="chord-grid"></div>
                <div id="modal-chord-types" class="chord-grid" style="display: none;"></div>
                <div id="modal-bass-notes" class="chord-grid" style="display: none;"></div>
            </div>
            <div class="dialog-buttons">
                <button id="modal-btn-remove" class="btn-danger">Ta bort ackord</button>
                <button id="modal-btn-done" class="btn-primary" style="display: none;"></button>
                <button id="modal-btn-close">St√§ng</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
        // ... Javascriptet √§r n√§stan helt of√∂r√§ndrat, men klistrar in hela f√∂r att vara s√§ker.
        // Relevanta √§ndringar √§r markerade.

        const SHARED_SONG_LIST_URL = 'https://raw.githubusercontent.com/Gobonkers65/ProChorder/main/songs-backup.json';

        class StableChordEditor {
            static STORAGE_KEYS = {
                PROJECTS: 'stableProjects',
                LAST_PROJECT: 'lastProject',
                DARK_MODE: 'darkMode'
            };
            // *** L√ÑGG TILL HELA DENNA NYA FUNKTION ***
            // ERS√ÑTT HELA DIN GAMLA handleAutoLinking-FUNKTION MED DENNA NYA
            // ERS√ÑTT HELA DIN GAMLA handleAutoLinking-FUNKTION MED DENNA F√ñRB√ÑTTRADE VERSION
            handleAutoLinking(e) {
                if (e.key !== ' ' && e.key !== 'Enter') return;

                const selection = window.getSelection();
                if (!selection.rangeCount || !selection.isCollapsed) return;

                const range = selection.getRangeAt(0);
                const container = range.startContainer;
                if (container.nodeType !== Node.TEXT_NODE) return;

                const textContent = container.textContent.substring(0, range.startOffset);

                // -- MER ROBUST REGEX H√ÑR --
                const customLinkRegex = /\[\[(.+?)(?:\|(.*?))?\]\]\s*$/;
                const autoLinkRegex = /(?:^|\s)((?:https?:\/\/\S+|(?:www|ftp)\.\S+))\s*$/;

                const customMatch = textContent.match(customLinkRegex);
                const autoMatch = !customMatch && textContent.match(autoLinkRegex); // K√∂r bara auto om custom misslyckas

                let url, linkText, startIndex, fullMatchLength;

                if (customMatch) {
                    url = customMatch[1].trim();
                    linkText = (customMatch[2] || '').trim() || url; // Anv√§nd text om den finns, annars URL
                    const fullMatchString = customMatch[0].trimEnd();
                    startIndex = textContent.lastIndexOf(fullMatchString);
                    fullMatchLength = fullMatchString.length;
                } else if (autoMatch) {
                    url = autoMatch[1];
                    linkText = url;
                    startIndex = textContent.lastIndexOf(url);
                    fullMatchLength = url.length;
                } else {
                    return; // Ingen matchning
                }

                if (!url || startIndex === -1) return; // S√§kerhetskoll

                e.preventDefault(); // F√∂rhindra att mellanslag/enter skrivs ut

                const replaceRange = document.createRange();
                replaceRange.setStart(container, startIndex);
                replaceRange.setEnd(container, startIndex + fullMatchLength);
                replaceRange.deleteContents();

                const link = document.createElement('a');
                link.href = url.startsWith('http') || url.startsWith('//') ? url : `http://${url}`;
                link.textContent = linkText;
                link.target = '_blank';
                link.rel = 'noopener noreferrer';
                replaceRange.insertNode(link);

                // √Öterst√§ll mark√∂ren efter den nya l√§nken
                range.setStartAfter(link);
                range.collapse(true);
                selection.removeAllRanges();
                selection.addRange(range);

                this.recordHistoryDebounced();
            }

            constructor(editorId) {
                this.editor = document.getElementById(editorId);
                this.editMode = 'chord';
                this.draggedChord = null;
                this.scrollInterval = null;
                this.scrollSpeed = 0.2;
                this.history = [];
                this.historyIndex = -1;
                this.debounceTimer = null;
                this.currentlyEditing = null;
                this.musicalNotes = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
                this.bassNotes = ["A", "A#", "B", "C", "C#", "D", "D#", "E", "F", "F#", "G", "G#"];
                this.chordTypes = ["", "m", "7", "m7", "maj7", "dim", "aug", "sus2", "sus4", "6", "9"];
                this.historyMax = 100;
                this.MIN_MOVE_SPEED = 0.02;
                this.MAX_MOVE_SPEED = 0.5;
                this.selectElements();
                this.observer = new MutationObserver(this.handleMutations.bind(this));
                this.init();
            }

            selectElements() {

                this.hamburgerBtn = document.getElementById('hamburger-btn');
                this.sideMenu = document.getElementById('side-menu');
                this.menuOverlay = document.getElementById('menu-overlay');
                this.container = document.querySelector('.container');
                this.titleInput = document.getElementById('song-title');
                this.authorInput = document.getElementById('song-author');
                this.editModeLabel = document.getElementById('edit-mode-label');
                this.btnToggleEditMode = document.getElementById('btn-toggle-edit-mode');

                // *** NYTT: L√§gger till den nya knappen i toppraden ***
                this.mainToggleEditModeBtn = document.getElementById('main-toggle-edit-mode-btn');

                this.btnToggleScrollMode = document.getElementById('btn-toggle-scroll-mode');
                this.sectionTypeSelect = document.getElementById('section-type-select-menu');
                this.btnInsertSection = document.getElementById('btn-insert-section');
                this.fontSizeSlider = document.getElementById('font-size-slider');
                this.projectList = document.getElementById('project-list');
                this.btnNewProject = document.getElementById('btn-new-project');
                this.btnSaveProject = document.getElementById('btn-save-project');
                this.btnDeleteProject = document.getElementById('btn-delete-project');
                this.btnDeleteAllProjects = document.getElementById('btn-delete-all-projects');
                this.btnTransposeUp = document.getElementById('btn-transpose-up');
                this.btnTransposeDown = document.getElementById('btn-transpose-down');
                this.btnExportPdf = document.getElementById('btn-export-pdf');
                this.btnExportTxt = document.getElementById('btn-export-txt');
                this.btnExportZip = document.getElementById('btn-export-zip');
                this.btnToggleDarkMode = document.getElementById('btn-toggle-dark-mode');
                this.btnShowHelp = document.getElementById('btn-show-help');
                this.btnExportJson = document.getElementById('btn-export-json');
                this.btnExportAllJson = document.getElementById('btn-export-all-json');
                this.btnImportJson = document.getElementById('btn-import-json');
                this.fileImport = document.getElementById('file-import');
                this.btnImportUrl = document.getElementById('btn-import-url');
                this.chordEditorModal = document.getElementById('chord-editor-modal');
                this.modalChordTarget = document.getElementById('modal-chord-target');
                this.modalRootNotes = document.getElementById('modal-root-notes');
                this.modalChordTypes = document.getElementById('modal-chord-types');
                this.modalBassNotes = document.getElementById('modal-bass-notes');
                this.modalBtnRemove = document.getElementById('modal-btn-remove');
                this.modalBtnClose = document.getElementById('modal-btn-close');
                this.modalBtnDone = document.getElementById('modal-btn-done');
                this.scrollControls = document.getElementById('scroll-controls');
                this.scrollBtnPlayPause = document.getElementById('scroll-btn-play-pause');
                this.scrollBtnExit = document.getElementById('scroll-btn-exit');
                this.scrollSpeedSlider = document.getElementById('scroll-speed-slider');
                this.scrollDurationMinutesInput = document.getElementById('scroll-duration-minutes');
                this.scrollDurationSecondsInput = document.getElementById('scroll-duration-seconds');
                this.dropIndicator = document.createElement('div');
                this.dropIndicator.id = 'drop-indicator';
                document.body.appendChild(this.dropIndicator);
                this.floatingLiveBtn = document.getElementById('floating-live-btn');
            }

            init() {
                this.populateSelects();
                this.applySavedTheme();
                this.setupEventListeners();
                this.updateModeUI();
                this.setScrollSpeed(this.scrollSpeedSlider.value);
                this.updateDurationFromSpeed();
                this.startObserver();
                this.loadLastProject();
            }

            populateSelects() {
                const sectionData = ["Intro", "Verse", "Chorus", "Stick", "Bridge", "Solo", "Outro", "Dig"];
                const populate = (sel, options, placeholder) => {
                    if (!sel) return;
                    sel.innerHTML = `<option value="" disabled selected>${placeholder}</option>`;
                    options.forEach(o => sel.innerHTML += `<option value="${o}">${o}</option>`);
                };
                populate(this.sectionTypeSelect, sectionData, 'Select Section...');
            }

            applySavedTheme() {
                const isDarkMode = localStorage.getItem(StableChordEditor.STORAGE_KEYS.DARK_MODE) === 'enabled';
                if (isDarkMode) {
                    document.body.classList.add('dark-mode');
                    this.btnToggleDarkMode.textContent = '‚òÄÔ∏è';
                } else {
                    document.body.classList.remove('dark-mode');
                    this.btnToggleDarkMode.textContent = 'üåô';
                }
            }

            startObserver() {
                this.observer.observe(this.editor, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            }

            stopObserver() {
                this.observer.disconnect();
            }

            // *** NYTT: √Öteranv√§ndbar funktion f√∂r att v√§xla l√§ge ***
            toggleEditMode() {
                this.editMode = this.editMode === 'chord' ? 'text' : 'chord';
                this.updateModeUI();
            }

            setupEventListeners() {
                this.floatingLiveBtn.addEventListener('click', () => {
                    this.toggleScrollMode(true, true);
                });
                const toggleMenu = () => {
                    this.sideMenu.classList.toggle('is-closed');
                    this.menuOverlay.classList.toggle('is-closed');
                };
                this.hamburgerBtn.addEventListener('click', toggleMenu);
                this.menuOverlay.addEventListener('click', toggleMenu);

                this.titleInput.addEventListener('blur', async () => {
                    const oldName = this.projectList.value;
                    const newName = this.titleInput.value.trim();
                    if (oldName && newName && oldName !== newName) {
                        const confirmed = await this.showCustomConfirm(`Do you want to rename this project "${oldName}" till "${newName}"?`);
                        if (confirmed) {
                            this.renameProject(oldName, newName);
                        } else {
                            this.titleInput.value = oldName;
                        }
                    }
                });

                // *** NYTT: B√•da knapparna anropar samma funktion ***
                this.btnToggleEditMode.addEventListener('click', () => this.toggleEditMode());
                this.mainToggleEditModeBtn.addEventListener('click', () => this.toggleEditMode());

                this.btnToggleScrollMode.addEventListener('click', () => {
                    this.toggleScrollMode(true);
                    if (!this.sideMenu.classList.contains('is-closed')) {
                        toggleMenu();
                    }
                });
                this.modalBtnClose.addEventListener('click', () => this.closeChordModal());
                this.modalBtnRemove.addEventListener('click', () => this.removeChord());
                this.scrollBtnExit.addEventListener('click', () => this.toggleScrollMode(false));
                // NYA, KORREKTA KODEN
                this.editor.addEventListener('click', (e) => {
                    const link = e.target.closest('a');

                    // Om klicket var p√• en l√§nk
                    if (link && link.href) {
                        // F√∂rhindra standardbeteendet (som √§r att placera textmark√∂ren)
                        e.preventDefault();
                        // √ñppna l√§nken manuellt i en ny flik
                        window.open(link.href, '_blank');
                        // Avsluta funktionen h√§r s√• att ackord-logiken inte k√∂rs
                        return;
                    }

                    // Om det inte var en l√§nk, forts√§tt med den vanliga ackord-logiken
                    if (this.editMode !== 'chord') return;
                    const clickedChord = e.target.closest('.chord');
                    if (clickedChord) {
                        this.openChordModal(clickedChord, null);
                    } else {
                        const range = this.getWordAtCursor(e);
                        if (range) this.openChordModal(null, range);
                    }
                });
                this.editor.addEventListener('keydown', this.handleKeyDown.bind(this));
                this.editor.addEventListener('paste', e => {
                    e.preventDefault();
                    const text = (e.clipboardData || window.clipboardData).getData('text/plain');
                    document.execCommand('insertText', false, text);
                });
                this.editor.addEventListener('input', () => this.recordHistoryDebounced());
                this.editor.addEventListener('keyup', this.handleAutoLinking.bind(this));
                document.querySelectorAll('.sidebar-group-label').forEach(label => {
                    label.addEventListener('click', () => {
                        const content = label.nextElementSibling;
                        const wasOpen = label.classList.contains('is-open');

                        label.closest('#side-menu').querySelectorAll('.sidebar-group-label').forEach(otherLabel => {
                            otherLabel.classList.remove('is-open');
                            otherLabel.nextElementSibling.classList.add('is-collapsed');
                        });

                        if (!wasOpen) {
                            label.classList.add('is-open');
                            content.classList.remove('is-collapsed');
                        }
                    });
                });

                this.editor.addEventListener('dragover', this.handleDragOver.bind(this));
                this.editor.addEventListener('dragleave', () => this.dropIndicator.style.display = 'none');
                this.editor.addEventListener('drop', this.handleDrop.bind(this));
                this.projectList.addEventListener('change', () => {
                    const name = this.projectList.value || '';
                    if (name) {
                        this.loadProject(name);
                    }
                });
                this.btnNewProject.addEventListener('click', async () => {
                    if (await this.showCustomConfirm('Are you sure? Unsaved changes will be lost!.')) {
                        this.createNewProject();
                    }
                });
                this.btnSaveProject.addEventListener('click', () => {
                    const name = this.titleInput.value.trim();
                    if (!name) return this.showCustomAlert('Name your song.');
                    this.saveProject(name);
                });
                this.btnDeleteProject.addEventListener('click', async () => {
                    const name = this.projectList.value;
                    if (!name) return this.showCustomAlert('Select a project to remove.');
                    if (await this.showCustomConfirm(`Delete projeckt "${name}"? This cannot be undone!`)) this.deleteProject(name);
                });
                this.btnDeleteAllProjects.addEventListener('click', () => this.deleteAllProjects());
                this.btnTransposeUp.addEventListener('click', () => this.transpose(1));
                this.btnTransposeDown.addEventListener('click', () => this.transpose(-1));
                this.fontSizeSlider.addEventListener('input', e => this.editor.style.fontSize = e.target.value + 'px');
                this.btnExportPdf.addEventListener('click', () => this.exportPdf());
                this.btnExportTxt.addEventListener('click', () => this.exportTxt());
                this.btnExportZip.addEventListener('click', () => this.exportAllAsZip());
                this.btnToggleDarkMode.addEventListener('click', () => this.toggleDarkMode());
                this.btnShowHelp.addEventListener('click', () => {
                    // Byt ut URL:en nedan mot den exakta l√§nken till din hj√§lpsida p√• GitHub
                    window.open('https://gobonkers65.github.io/ProChorder/help', '_blank');
                });
                this.btnExportJson.addEventListener('click', () => this.exportJson());
                this.btnExportAllJson.addEventListener('click', () => this.exportAllJson());
                this.btnImportJson.addEventListener('click', () => this.fileImport.click());
                this.fileImport.addEventListener('change', e => this.importJsonFromFile(e.target.files[0]));
                this.btnImportUrl.addEventListener('click', async () => {
                    const confirmed = await this.showCustomConfirm('Ladda l√•tlista fr√•n GitHub? Lokala l√•tar med samma titel skrivs √∂ver.');
                    if (confirmed) this.importJsonFromUrl(SHARED_SONG_LIST_URL);
                });
                this.scrollBtnPlayPause.addEventListener('click', () => this.toggleScrolling());
                this.scrollSpeedSlider.addEventListener('input', e => {
                    this.setScrollSpeed(e.target.value);
                    this.updateDurationFromSpeed();
                });
                const durationChangeHandler = () => {
                    const totalSeconds = this.getTotalDurationSeconds();
                    if (totalSeconds > 0) this.setScrollForDuration(totalSeconds);
                };
                this.scrollDurationMinutesInput.addEventListener('input', durationChangeHandler);
                this.scrollDurationSecondsInput.addEventListener('input', durationChangeHandler);
                document.addEventListener('keydown', e => {
                    if (this.editMode === 'scroll') {
                        if (e.key === ' ') { e.preventDefault(); this.toggleScrolling(); }
                        if (e.key === 'Escape') this.toggleScrollMode(false);
                        return;
                    }
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); this.undo(); }
                    if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) { e.preventDefault(); this.redo(); }
                });
                this.btnInsertSection.addEventListener('click', () => {
                    if (this.editMode === 'scroll') return;
                    const sectionType = this.sectionTypeSelect.value;
                    if (sectionType) {
                        this.insertSectionMarker(sectionType);
                        this.recordHistoryDebounced();
                        this.sectionTypeSelect.selectedIndex = 0;
                    } else {
                        this.showCustomAlert('Choose selection type');
                    }
                });
            }

            // *** NYTT: updateModeUI uppdaterar nu b√•da knapparna ***
            updateModeUI() {
                if (this.editMode === 'chord') {
                    // Texter inuti hamburgermenyn
                    this.editModeLabel.textContent = 'Edit (Chords)';
                    this.btnToggleEditMode.textContent = 'Switch to Lyrics Mode';

                    // Text f√∂r knappen i toppraden
                    if (this.mainToggleEditModeBtn) {
                        this.mainToggleEditModeBtn.textContent = 'C'; // Visar nuvarande l√§ge: Chords
                        this.mainToggleEditModeBtn.title = 'Switch to Lyrics Mode';
                    }
                    this.editor.classList.remove('text-mode');
                } else if (this.editMode === 'text') {
                    // Texter inuti hamburgermenyn
                    this.editModeLabel.textContent = 'Edit (Lyrics)';
                    this.btnToggleEditMode.textContent = 'Switch to Chord Mode';

                    // Text f√∂r knappen i toppraden
                    if (this.mainToggleEditModeBtn) {
                        this.mainToggleEditModeBtn.textContent = 'L'; // Visar nuvarande l√§ge: Lyrics
                        this.mainToggleEditModeBtn.title = 'Switch to Chord Mode';
                    }
                    this.editor.classList.add('text-mode');
                }
            }

            // ... resten av koden √§r of√∂r√§ndrad ...

            // ERS√ÑTT DEN GAMLA FUNKTIONEN MED DENNA
            toggleScrollMode(enter, startImmediately = false) {
                if (enter) {
                    if (!this.editor.textContent.trim()) {
                        this.showCustomAlert("L√§gg till text innan du startar Live Mode.");
                        return;
                    }
                    this.editMode = 'scroll';
                    this.editor.contentEditable = false;
                    document.body.classList.add('scroll-mode-active');
                    setTimeout(() => {
                        const scrollHeight = this.editor.scrollHeight - this.editor.clientHeight;
                        if (scrollHeight <= 0) {
                            this.showCustomAlert("Texten √§r f√∂r kort f√∂r att scrolla.");
                            this.toggleScrollMode(false);
                            return;
                        }

                        // Vi beh√∂ver inte l√§ngre ber√§kna hastigheten h√§r.
                        // Det sk√∂ter startScrolling() sj√§lv.

                        if (startImmediately) {
                            this.startScrolling();
                        }
                    }, 100);
                } else {
                    this.stopScrolling();
                    this.editMode = 'chord';
                    this.editor.contentEditable = true;
                    document.body.classList.remove('scroll-mode-active');
                    this.updateModeUI();
                }
            }
            centerChordHandles() { this.editor.querySelectorAll('.chord').forEach(chordEl => { const handle = chordEl.querySelector('.chord-handle'); const text = chordEl.querySelector('.chord-text'); if (handle && text) { const textWidth = text.offsetWidth; handle.style.left = `${textWidth / 2}px`; } }); }
            openChordModal(element, range) { this.currentlyEditing = { element, range }; if (element) { this.modalChordTarget.textContent = `Redigerar: ${element.dataset.chord}`; this.modalBtnRemove.style.display = 'inline-block'; } else if (range) { this.modalChordTarget.textContent = `L√§gg till vid: "${range.toString()}"`; this.modalBtnRemove.style.display = 'none'; } this.renderRootNotes(); this.chordEditorModal.classList.add('visible'); }
            renderRootNotes() { this.modalChordTarget.textContent = 'Select keynote'; this.modalRootNotes.innerHTML = ''; this.musicalNotes.forEach(note => { const button = document.createElement('button'); button.textContent = note; button.addEventListener('click', () => this.renderChordTypes(note)); this.modalRootNotes.appendChild(button); }); this.modalRootNotes.style.display = 'grid'; this.modalChordTypes.style.display = 'none'; this.modalBassNotes.style.display = 'none'; }
            // ERS√ÑTT DEN GAMLA FUNKTIONEN MED DENNA NYA VERSION
            renderChordTypes(rootNote) {
                this.modalChordTarget.textContent = `Select type (Keynote: ${rootNote})`;
                this.modalChordTypes.innerHTML = '';
                const backButton = document.createElement('button');
                backButton.textContent = '‚Äπ Tillbaka';
                backButton.addEventListener('click', () => this.renderRootNotes());
                this.modalChordTypes.appendChild(backButton);

                this.chordTypes.forEach(type => {
                    const mainChord = rootNote + type;
                    const button = document.createElement('button');

                    // H√ÑR √ÑR DEN VIKTIGA LOGIKEN:
                    if (type === '') {
                        // Om det √§r ett rent grundackord (t.ex. "A")
                        button.textContent = `Use ${mainChord}`;
                        button.classList.add('active');
                        // Denna knapp anropar applyChord DIREKT och avslutar.
                        button.addEventListener('click', () => this.applyChord(mainChord));
                    } else {
                        // F√∂r alla andra ackord (Am, A7 etc.)
                        button.textContent = mainChord;
                        // Dessa knappar g√•r vidare till sista steget som vanligt.
                        button.addEventListener('click', () => this.renderBassNotes(mainChord, rootNote));
                    }
                    this.modalChordTypes.appendChild(button);
                });

                this.modalRootNotes.style.display = 'none';
                this.modalChordTypes.style.display = 'grid';
                this.modalBassNotes.style.display = 'none';
            }
            renderBassNotes(mainChord, rootNote) { this.modalChordTarget.textContent = `Select Bass Key (Chord: ${mainChord})`; this.modalBassNotes.innerHTML = ''; const backButton = document.createElement('button'); backButton.textContent = '‚Äπ Tillbaka'; backButton.addEventListener('click', () => this.renderChordTypes(rootNote)); this.modalBassNotes.appendChild(backButton); const doneButton = document.createElement('button'); doneButton.textContent = `Use ${mainChord}`; doneButton.classList.add('active'); doneButton.addEventListener('click', () => this.applyChord(mainChord)); this.modalBassNotes.appendChild(doneButton); this.bassNotes.forEach(note => { const finalChord = `${mainChord}/${note}`; const button = document.createElement('button'); button.textContent = `/${note}`; button.addEventListener('click', () => this.applyChord(finalChord)); this.modalBassNotes.appendChild(button); }); this.modalRootNotes.style.display = 'none'; this.modalChordTypes.style.display = 'none'; this.modalBassNotes.style.display = 'grid'; }
            applyChord(chordName) { if (!this.currentlyEditing) return; if (this.currentlyEditing.element) { const chordTextEl = this.currentlyEditing.element.querySelector('.chord-text'); this.currentlyEditing.element.dataset.chord = chordName; if (chordTextEl) chordTextEl.textContent = chordName; } else if (this.currentlyEditing.range) { const range = this.currentlyEditing.range; const wordText = range.toString(); range.deleteContents(); const chordSpan = this.createChordSpan(chordName); range.insertNode(chordSpan); const textNode = document.createTextNode(" " + wordText); range.setStartAfter(chordSpan); range.insertNode(textNode); } this.centerChordHandles(); this.recordHistoryDebounced(); this.closeChordModal(); }
            closeChordModal() { this.chordEditorModal.classList.remove('visible'); this.currentlyEditing = null; }
            removeChord() { if (this.currentlyEditing?.element) { this.currentlyEditing.element.remove(); this.recordHistoryDebounced(); } this.closeChordModal(); }
            getWordAtCursor(event) { try { const range = document.caretRangeFromPoint(event.clientX, event.clientY); if (!range || !range.startContainer.textContent) return null; const text = range.startContainer.textContent; let startIndex = range.startOffset; let endIndex = range.startOffset; while (startIndex > 0 && text[startIndex - 1].trim() !== '') startIndex--; while (endIndex < text.length && text[endIndex].trim() !== '') endIndex++; if (startIndex === endIndex) return null; const wordRange = document.createRange(); wordRange.setStart(range.startContainer, startIndex); wordRange.setEnd(range.startContainer, endIndex); return wordRange; } catch (e) { return null; } }
            handleDragOver(e) { e.preventDefault(); if (this.editMode !== 'chord') return; if (e.ctrlKey || e.altKey) e.dataTransfer.dropEffect = 'copy'; else e.dataTransfer.dropEffect = 'move'; let range; if (document.caretRangeFromPoint) range = document.caretRangeFromPoint(e.clientX, e.clientY); else { const pos = document.caretPositionFromPoint(e.clientX, e.clientY); if (pos) { range = document.createRange(); range.setStart(pos.offsetNode, pos.offset); } } if (range) { const rect = range.getBoundingClientRect(); this.dropIndicator.style.display = 'block'; this.dropIndicator.style.left = `${rect.left + window.scrollX}px`; this.dropIndicator.style.top = `${rect.top + window.scrollY}px`; } }
            handleDrop(e) { e.preventDefault(); e.stopPropagation(); this.dropIndicator.style.display = 'none'; if (this.editMode !== 'chord') return; let range = null; if (document.caretRangeFromPoint) range = document.caretRangeFromPoint(e.clientX, e.clientY); else if (document.caretPositionFromPoint) { const pos = document.caretPositionFromPoint(e.clientX, e.clientY); if (pos) { range = document.createRange(); range.setStart(pos.offsetNode, pos.offset); range.collapse(true); } } if (!range || !this.editor.contains(range.startContainer)) { range = document.createRange(); range.selectNodeContents(this.editor); range.collapse(false); } let chordNode; if ((e.ctrlKey || e.altKey) && this.draggedChord) { const chordText = this.draggedChord.dataset.chord; chordNode = this.createChordSpan(chordText); } else { chordNode = this.draggedChord ? this.draggedChord : this.createChordSpan(e.dataTransfer.getData('text/plain')); } chordNode.style.display = 'inline-block'; range.insertNode(chordNode); const sel = window.getSelection(); sel.removeAllRanges(); const after = document.createRange(); after.setStartAfter(chordNode); after.collapse(true); sel.addRange(after); this.centerChordHandles(); this.recordHistoryDebounced(); }
            createChordSpan(chord) {
                const span = document.createElement('span');
                span.className = 'chord';
                span.dataset.chord = chord;
                span.setAttribute('contenteditable', 'false');
                const chordText = document.createElement('span'); chordText.className = 'chord-text'; chordText.textContent = chord; chordText.spellcheck = false; span.appendChild(chordText); const handle = document.createElement('span'); handle.className = 'chord-handle'; handle.draggable = true; span.appendChild(handle); span.addEventListener('click', e => { if (this.editMode !== 'chord' || e.target === handle) return; e.stopPropagation(); this.clearChordSelection(); span.classList.add('selected'); }); span.addEventListener('dblclick', e => { if (this.editMode !== 'chord') return; e.stopPropagation(); span.remove(); this.recordHistoryDebounced(); }); handle.addEventListener('dragstart', e => { if (this.editMode !== 'chord') { e.preventDefault(); return; } e.stopPropagation(); e.dataTransfer.setData('text/plain', chord); e.dataTransfer.effectAllowed = 'copyMove'; this.draggedChord = span; document.body.classList.add('is-dragging'); if (e.dataTransfer.setDragImage) { const ghost = document.createElement('span'); ghost.textContent = chord; ghost.style.cssText = `display:inline-block;padding:0.1em 0.4em;border-radius:3px;background-color:${getComputedStyle(document.body).getPropertyValue('--surface')};color:${getComputedStyle(document.body).getPropertyValue('--chord-color')};font-family:var(--font-sans);font-weight:600;font-size:0.85em;border:1px solid ${getComputedStyle(document.body).getPropertyValue('--border')};position:absolute;top:-9999px;left:-9999px;`; document.body.appendChild(ghost); e.dataTransfer.setDragImage(ghost, 10, 15); setTimeout(() => document.body.removeChild(ghost), 0); } const isCopy = e.ctrlKey || e.altKey; if (!isCopy) { setTimeout(() => { span.style.display = 'none'; }, 0); } }); handle.addEventListener('dragend', e => { e.stopPropagation(); document.body.classList.remove('is-dragging'); if (this.draggedChord && this.draggedChord.parentNode) { this.draggedChord.style.display = 'inline-block'; } this.draggedChord = null; }); return span;
            }
            insertSectionMarker(type) { if (this.editMode === 'scroll') return; const sel = window.getSelection(); if (!sel.rangeCount || !this.editor.contains(sel.anchorNode)) return this.showCustomAlert('Place the marker on the row where yot want to insert the section marker.'); let node = sel.anchorNode; while (node && node.parentNode !== this.editor) node = node.parentNode; if (!node || node.tagName !== 'DIV') { const newDiv = document.createElement('div'); this.editor.appendChild(newDiv); node = newDiv; } const existingMarker = node.querySelector('.section-marker'); if (existingMarker) existingMarker.remove(); this.insertSectionMarkerInDiv(node, type); }
            insertSectionMarkerInDiv(div, type) { const abbreviations = { 'Verse': 'V', 'Chorus': 'R', 'Stick': 'S', 'Intro': 'I', 'Outro': 'O', 'Solo': 'Solo', 'Bridge': 'B', 'Dig': 'M' }; const markerSpan = document.createElement('span'); markerSpan.className = 'section-marker'; markerSpan.dataset.section = type; markerSpan.setAttribute('contenteditable', 'false'); markerSpan.dataset.abbreviation = abbreviations[type] || type.charAt(0); const textSpan = document.createElement('span'); textSpan.className = 'section-marker-text'; textSpan.textContent = type; markerSpan.appendChild(textSpan); div.insertBefore(markerSpan, div.firstChild); }
            clearChordSelection() { this.editor.querySelectorAll('.chord.selected').forEach(s => s.classList.remove('selected')); }
            handleKeyDown(e) { if (this.editMode !== 'chord') return; if (e.key === 'Backspace') { const sel = window.getSelection(); if (!sel.rangeCount) return; const range = sel.getRangeAt(0); if (range.collapsed && range.startOffset === 0) { const container = range.startContainer; const prev = (container.nodeType === Node.TEXT_NODE ? container : container.childNodes[range.startOffset] || null)?.previousSibling; if (prev && prev.nodeType === Node.ELEMENT_NODE && prev.classList.contains('chord')) { e.preventDefault(); prev.remove(); this.recordHistoryDebounced(); } } } }
            handleMutations(mutations) { this.stopObserver(); mutations.forEach(mutation => { if (mutation.type === 'characterData') this.formatNode(mutation.target); else if (mutation.type === 'childList') mutation.addedNodes.forEach(n => { if (n.nodeType === Node.TEXT_NODE) this.formatNode(n); }); }); this.startObserver(); }
            formatNode(node) { if (this.editMode !== 'chord' || !node.textContent || !node.textContent.includes('[')) return; const text = node.textContent; const regex = /\[([^\]]+)\]/g; let match; const frag = document.createDocumentFragment(); let lastIndex = 0; let replaced = false; while ((match = regex.exec(text)) !== null) { replaced = true; const beforeText = text.substring(lastIndex, match.index); if (beforeText) frag.appendChild(document.createTextNode(beforeText)); const chord = match[1]; const chordSpan = this.createChordSpan(chord); frag.appendChild(chordSpan); lastIndex = regex.lastIndex; } if (replaced) { const afterText = text.substring(lastIndex); if (afterText) frag.appendChild(document.createTextNode(afterText)); if (node.parentNode) { const parent = node.parentNode; parent.replaceChild(frag, node); const sel = window.getSelection(); const range = document.createRange(); const lastNode = parent.childNodes[parent.childNodes.length - 1]; if (lastNode) { range.setStart(lastNode, lastNode.length || lastNode.childNodes.length); range.collapse(true); sel.removeAllRanges(); sel.addRange(range); } this.centerChordHandles(); } } }
            syncChordData() { this.editor.querySelectorAll('.chord').forEach(chordEl => { const chordTextEl = chordEl.querySelector('.chord-text'); if (chordTextEl) chordEl.dataset.chord = chordTextEl.textContent; }); }
            getContentAsText() {
                let result = [];
                this.editor.childNodes.forEach(lineDiv => {
                    let lineText = '';
                    if (lineDiv.nodeType !== Node.ELEMENT_NODE) return;

                    const marker = lineDiv.querySelector('.section-marker');
                    if (marker) {
                        lineText += `::${marker.dataset.section}::`;
                    }

                    lineDiv.childNodes.forEach(node => {
                        if (node.nodeType === Node.TEXT_NODE) {
                            lineText += node.textContent;
                        } else if (node.matches && node.matches('.chord')) {
                            lineText += `[${node.dataset.chord}]`;
                        }
                        // *** DETTA √ÑR DEN TILLAGDA DELEN ***
                        else if (node.tagName === 'A') {
                            lineText += `[[${node.href}|${node.textContent}]]`;
                        }
                    });
                    result.push(lineText);
                });
                return result.join('\n');
            }
            // ERS√ÑTT HELA DIN GAMLA loadContent-FUNKTION MED DENNA DEFINITIVA VERSION
            loadContent(text, recordHistory = false) {
                this.stopObserver();
                this.editor.innerHTML = '';
                const lines = text.split('\n');
                lines.forEach(lineText => {
                    lineText = lineText.replace(/\[\s*\]/g, '');
                    const lineDiv = document.createElement('div');
                    let sectionType = null;
                    lineText = lineText.replace(/^::(.*?)::/, (match, type) => {
                        sectionType = type;
                        return '';
                    });
                    if (sectionType) this.insertSectionMarkerInDiv(lineDiv, sectionType);

                    if (lineText.trim() === '' && !lineText.includes('[')) {
                        lineDiv.appendChild(document.createElement('br'));
                    } else {
                        // -- DEN NYA, SMARTARE REGEXEN SOM L√ñSER ALLT --
                        // Denna regex kan nu tydligt skilja p√• [[L√§nk]] och [Ackord].
                        const regex = /\[\[(.+?)(?:\|(.*?))?\]\]|\[([^\]]+)\]/g;
                        let lastIndex = 0;
                        let match;

                        while ((match = regex.exec(lineText)) !== null) {
                            // L√§gg till texten som kommer f√∂re matchningen
                            if (match.index > lastIndex) {
                                lineDiv.appendChild(document.createTextNode(lineText.substring(lastIndex, match.index)));
                            }

                            // KOLLA OM DET √ÑR EN L√ÑNK (grupp 1 finns) ELLER ETT ACKORD (grupp 3 finns)
                            if (match[1]) { // Det √§r en l√§nk, t.ex. [[URL|Text]]
                                const url = match[1].trim();
                                const linkText = (match[2] || '').trim() || url; // Anv√§nd text om den finns, annars URL

                                const link = document.createElement('a');
                                link.href = url.startsWith('http') ? url : `http://${url}`; // S√§kerst√§ll http
                                link.textContent = linkText;
                                link.target = '_blank';
                                link.rel = 'noopener noreferrer';
                                lineDiv.appendChild(link);

                            } else if (match[3]) { // Det √§r ett ackord, t.ex. [Am]
                                lineDiv.appendChild(this.createChordSpan(match[3]));
                            }

                            lastIndex = match.index + match[0].length;
                        }
                        // L√§gg till eventuell text efter sista matchningen
                        if (lastIndex < lineText.length) {
                            lineDiv.appendChild(document.createTextNode(lineText.substring(lastIndex)));
                        }
                    }
                    this.editor.appendChild(lineDiv);
                });
                this.centerChordHandles();
                this.startObserver();
                if (recordHistory) this.recordHistory();
            }
            _transposeSingleNote(note, steps) { const sharpMap = { 'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#' }; const match = note.match(/^([A-G](?:#|b)?)/); if (!match) return note; let rootNote = match[0]; let normalizedNote = rootNote.includes('b') ? (sharpMap[rootNote] || rootNote) : rootNote; const currentIndex = this.musicalNotes.indexOf(normalizedNote); if (currentIndex !== -1) { const newIndex = (currentIndex + steps + this.musicalNotes.length) % this.musicalNotes.length; const transposedRoot = this.musicalNotes[newIndex]; return transposedRoot + note.substring(rootNote.length); } return note; }
            transpose(steps) { if (this.editMode === 'scroll') return; this.syncChordData(); const text = this.getContentAsText(); const transposedText = text.replace(/\[([^\]]+)\]/g, (fullMatch, chord) => { const parts = chord.split('/'); const mainChord = parts[0]; const bassNote = parts.length > 1 ? parts[1] : null; const transposedMainChord = this._transposeSingleNote(mainChord, steps); if (bassNote) { const transposedBassNote = this._transposeSingleNote(bassNote, steps); return `[${transposedMainChord}/${transposedBassNote}]`; } else { return `[${transposedMainChord}]`; } }); this.loadContent(transposedText, true); }
            recordHistory() { this.syncChordData(); const snapshot = this.getContentAsText(); if (this.history[this.historyIndex] === snapshot) return; this.history = this.history.slice(0, this.historyIndex + 1); this.history.push(snapshot); if (this.history.length > this.historyMax) this.history.shift(); this.historyIndex = this.history.length - 1; }
            recordHistoryDebounced() { clearTimeout(this.debounceTimer); this.debounceTimer = setTimeout(() => this.recordHistory(), 300); }
            undo() { if (this.editMode === 'scroll') return; if (this.historyIndex > 0) { this.historyIndex--; this.loadContent(this.history[this.historyIndex], false); } }
            redo() { if (this.editMode === 'scroll') return; if (this.historyIndex < this.history.length - 1) { this.historyIndex++; this.loadContent(this.history[this.historyIndex], false); } }
            showCustomAlert(message) { const dialog = document.getElementById('custom-alert'); document.getElementById('custom-alert-message').textContent = message; dialog.classList.add('visible'); const okBtn = document.getElementById('custom-alert-ok'); const close = () => dialog.classList.remove('visible'); okBtn.onclick = close; }
            showCustomConfirm(message) { return new Promise(resolve => { const dialog = document.getElementById('custom-confirm'); document.getElementById('custom-confirm-message').textContent = message; dialog.classList.add('visible'); const okBtn = document.getElementById('custom-confirm-ok'); const cancelBtn = document.getElementById('custom-confirm-cancel'); const close = (value) => { dialog.classList.remove('visible'); resolve(value); }; okBtn.onclick = () => close(true); cancelBtn.onclick = () => close(false); }); }
            toggleDarkMode() { document.body.classList.toggle('dark-mode'); const isDarkMode = document.body.classList.contains('dark-mode'); localStorage.setItem(StableChordEditor.STORAGE_KEYS.DARK_MODE, isDarkMode ? 'enabled' : 'disabled'); this.btnToggleDarkMode.textContent = isDarkMode ? '‚òÄÔ∏è' : 'üåô'; }
            createNewProject() { this.titleInput.value = ''; this.authorInput.value = ''; this.loadContent('√ñppna sidopanelen och d√∂p ditt projekt. G√• sedan till "Projekt" och spara..', true); this.projectList.selectedIndex = 0; localStorage.removeItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); if (this.fontSizeSlider) { this.fontSizeSlider.value = 16; } this.editor.style.fontSize = '16px'; this.titleInput.focus(); }
            saveProject(name) { this.syncChordData(); const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {}; projects[name] = { title: this.titleInput.value, author: this.authorInput.value, fontSize: this.editor.style.fontSize || '16px', content: this.getContentAsText(), scrollSpeed: this.scrollSpeed, duration: this.getTotalDurationSeconds() }; localStorage.setItem(StableChordEditor.STORAGE_KEYS.PROJECTS, JSON.stringify(projects)); localStorage.setItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT, name); this.updateProjectList(name); const originalText = this.btnSaveProject.textContent; this.btnSaveProject.textContent = 'Saved'; this.btnSaveProject.disabled = true; setTimeout(() => { this.btnSaveProject.textContent = 'Save'; this.btnSaveProject.disabled = false; }, 1200); }
            // ERS√ÑTT HELA loadProject-FUNKTIONEN MED DENNA
            loadProject(name) {
                const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {};
                if (projects[name]) {
                    const data = projects[name];
                    this.titleInput.value = data.title || '';
                    this.authorInput.value = data.author || '';
                    this.editor.style.fontSize = data.fontSize || '16px';
                    if (this.fontSizeSlider) {
                        const num = parseInt((data.fontSize || '').replace('px', ''));
                        if (!isNaN(num)) this.fontSizeSlider.value = num;
                    }
                    this.loadContent(data.content || '', true);

                    // *** START P√Ö KORRIGERING ***

                    // Ladda scroll-hastighet
                    if (data.scrollSpeed !== undefined) {
                        // Ber√§kna och s√§tt slider-v√§rdet fr√•n det sparade this.scrollSpeed
                        const sliderVal = ((data.scrollSpeed - this.MIN_MOVE_SPEED) / (this.MAX_MOVE_SPEED - this.MIN_MOVE_SPEED)) * 100;
                        this.scrollSpeedSlider.value = Math.max(0, Math.min(100, Math.round(sliderVal)));
                        // S√§tt sj√§lva hastigheten
                        this.setScrollSpeed(this.scrollSpeedSlider.value);
                    } else {
                        // √Öterst√§ll till standard om inget v√§rde finns sparat
                        this.scrollSpeedSlider.value = 20; // Standardv√§rdet fr√•n HTML
                        this.setScrollSpeed(20);
                    }

                    // Ladda scroll-tid
                    if (data.duration !== undefined) {
                        this.updateDurationInputs(data.duration);
                    } else {
                        // Om ingen tid finns sparad, ber√§kna den fr√•n den nyladdade hastigheten
                        this.updateDurationFromSpeed();
                    }

                    // *** SLUT P√Ö KORRIGERING ***

                    localStorage.setItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT, name);
                    if (this.projectList.value !== name) this.projectList.value = name;
                }
            }
            loadLastProject() { this.updateProjectList(); const last = localStorage.getItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); if (last) this.loadProject(last); else this.loadContent('::Vers::\nWelcome to ProChorder!\n\n::Chorus::\nSkriv [Am], [G] etc. i Ackordl√§ge.', true); }
            updateProjectList(selectedValue) { const list = this.projectList; const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {}; const currentProjects = Object.keys(projects).sort(); list.innerHTML = '<option value="">Load project...</option>'; currentProjects.forEach(name => { const option = document.createElement('option'); option.value = name; option.textContent = name; list.appendChild(option); }); const last = selectedValue || localStorage.getItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); if (last && currentProjects.includes(last)) list.value = last; }
            deleteProject(name) { const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {}; delete projects[name]; localStorage.setItem(StableChordEditor.STORAGE_KEYS.PROJECTS, JSON.stringify(projects)); const last = localStorage.getItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); if (last === name) { localStorage.removeItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); this.createNewProject(); } this.updateProjectList(); this.showCustomAlert(`Project "${name}" Removed.`); }
            async deleteAllProjects() { if (await this.showCustomConfirm('Are you sure? This erase ALL songs permanently.')) { localStorage.removeItem(StableChordEditor.STORAGE_KEYS.PROJECTS); localStorage.removeItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); this.updateProjectList(); this.createNewProject(); this.showCustomAlert('All projects are removed.'); } }
            async renameProject(oldName, newName) { const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {}; if (projects[oldName] && !projects[newName]) { projects[newName] = projects[oldName]; projects[newName].title = newName; delete projects[oldName]; localStorage.setItem(StableChordEditor.STORAGE_KEYS.PROJECTS, JSON.stringify(projects)); const lastProject = localStorage.getItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT); if (lastProject === oldName) localStorage.setItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT, newName); this.titleInput.value = newName; this.updateProjectList(newName); this.showCustomAlert(`This project is now renamed "${newName}".`); } else if (projects[newName]) { this.showCustomAlert(`A project called "${newName}" already exist.`); } }
            generatePdfForProject(projectData) {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                let y = 20; const margin = 15;
                const baseFontSizePx = parseInt((projectData.fontSize || '16px').replace('px', ''), 10);
                const baseFontSizePt = baseFontSizePx * 0.75;
                const lyricLineHeightMultiplier = 0.7;
                const LYRIC_LINE_HEIGHT = baseFontSizePt * lyricLineHeightMultiplier;
                const SECTION_HEADER_LINE_HEIGHT = baseFontSizePt * 0.9;
                const CHORD_COLOR = '#0052cc';
                const TEXT_COLOR = '#172b4d';
                const CHORD_OFFSET = baseFontSizePt * 0.3;
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(18);
                doc.text(projectData.title || 'Song Title', 105, y, {
                    align: 'center'
                }); y += 8;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(12);
                doc.text(projectData.author || 'Artist', 105, y, { align: 'center' });
                y += 15; const lines = (projectData.content || '').split('\n');
                lines.forEach(lineText => {
                    let sectionType = null;
                    let remainingText = lineText.replace(/^::(.*?)::/, (match, type) => {
                        sectionType = type; return '';
                    });
                    if (sectionType) {
                        if (y > 280) {
                            doc.addPage();
                            y = 20;
                        }
                        if (y > 25) y += SECTION_HEADER_LINE_HEIGHT * 0.5; doc.setFont('helvetica', 'bold');
                        doc.setFontSize(baseFontSizePt * 1.1);
                        doc.setTextColor(TEXT_COLOR);
                        doc.text(sectionType, margin, y);
                        y += SECTION_HEADER_LINE_HEIGHT;
                    }
                    if (remainingText.trim()) {
                        if (y > 280) {
                            doc.addPage();
                            y = 20;
                        } const parts = remainingText.split(/(\[[^\]]+\])/g).filter(p => p);
                        let currentX = margin; parts.forEach(part => {
                            if (part.startsWith('[') && part.endsWith(']')) {
                                const chord = part.substring(1, part.length - 1);
                                doc.setFont('helvetica', 'bold');
                                doc.setFontSize(baseFontSizePt * 0.85);
                                doc.setTextColor(CHORD_COLOR);
                                doc.text(chord, currentX, y - CHORD_OFFSET);
                            }
                            else {
                                doc.setFont('helvetica', 'normal');
                                doc.setFontSize(baseFontSizePt);
                                doc.setTextColor(TEXT_COLOR);
                                doc.text(part, currentX, y);
                                currentX += doc.getTextWidth(part);
                            }
                        });
                        y += LYRIC_LINE_HEIGHT;
                    }
                    else if (!sectionType) {
                        y += LYRIC_LINE_HEIGHT * 0.7;
                    }
                });
                return doc.output('blob'

                );
            }
            exportPdf() { this.syncChordData(); const projectData = { title: this.titleInput.value, author: this.authorInput.value, content: this.getContentAsText(), fontSize: this.editor.style.fontSize }; const pdfBlob = this.generatePdfForProject(projectData); saveAs(pdfBlob, `${this.sanitizeFilename(projectData.title)}.pdf`); }
            exportTxt() { this.syncChordData(); const title = this.titleInput.value; const author = this.authorInput.value; const content = this.getContentAsText(); const fullText = `${title}\n${author}\n\n${content}`; const blob = new Blob([fullText], { type: "text/plain;charset=utf-8" }); saveAs(blob, `${this.sanitizeFilename(title)}.txt`); }
            async exportAllAsZip() { this.btnExportZip.textContent = 'Genererar...'; this.btnExportZip.disabled = true; try { const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {}; if (Object.keys(projects).length === 0) return this.showCustomAlert('No project to export.'); const zip = new JSZip(); for (const key in projects) { const project = projects[key]; const pdfBlob = this.generatePdfForProject(project); zip.file(`${this.sanitizeFilename(project.title)}.pdf`, pdfBlob); } const content = await zip.generateAsync({ type: "blob" }); saveAs(content, "alla-l√•tar.zip"); } catch (e) { this.showCustomAlert('Fel vid ZIP-export.'); } finally { this.btnExportZip.textContent = 'ZIP'; this.btnExportZip.disabled = false; } }
            exportJson() { this.syncChordData(); const projectData = { title: this.titleInput.value, author: this.authorInput.value, content: this.getContentAsText(), fontSize: this.editor.style.fontSize, scrollSpeed: this.scrollSpeed, duration: this.getTotalDurationSeconds() }; const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: "application/json" }); saveAs(blob, `${this.sanitizeFilename(projectData.title)}.json`); }
            exportAllJson() {
                const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {};
                // Convert the object of projects into an array of projects
                const projectsArray = Object.values(projects);
                const blob = new Blob([JSON.stringify(projectsArray, null, 2)], {
                    type: "application/json"
                });
                saveAs(blob, `songs-backup.json`);
            }
            importJsonFromFile(file) { if (!file) return; const reader = new FileReader(); reader.onload = async (e) => { try { const data = JSON.parse(e.target.result); if (Array.isArray(data)) { if (await this.showCustomConfirm(`${data.length} l√•tar hittades. Vill du importera? Existerande l√•tar med samma titel skrivs √∂ver.`)) this.importMultipleProjects(data); } else if (data.title) { this.importSingleProject(data); } } catch (e) { this.showCustomAlert('Fel vid import av JSON.'); } }; reader.readAsText(file); }
            async importJsonFromUrl(url) { try { const response = await fetch(url); if (!response.ok) throw new Error('Network response was not ok'); const data = await response.json(); if (Array.isArray(data)) this.importMultipleProjects(data); else if (data.title) this.importSingleProject(data); } catch (e) { this.showCustomAlert('Fel vid import fr√•n URL.'); } }
            importSingleProject(data) { this.titleInput.value = data.title || ''; this.authorInput.value = data.author || ''; this.editor.style.fontSize = data.fontSize || '16px'; this.loadContent(data.content || '', true); if (data.scrollSpeed) this.scrollSpeed = data.scrollSpeed; if (data.duration) this.updateDurationInputs(data.duration); this.saveProject(data.title); }
            importMultipleProjects(projectsArray) { const projects = JSON.parse(localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)) || {}; let importedCount = 0, overwrittenCount = 0; for (const project of projectsArray) { if (project && project.title) { if (projects[project.title]) overwrittenCount++; else importedCount++; projects[project.title] = project; } } localStorage.setItem(StableChordEditor.STORAGE_KEYS.PROJECTS, JSON.stringify(projects)); this.updateProjectList(); this.showCustomAlert(`${importedCount} nya l√•tar importerades. ${overwrittenCount} l√•tar uppdaterades.`); if (projectsArray.length > 0) this.loadProject(projectsArray[0].title); }
            sanitizeFilename(name) { return name.replace(/[\/\\?%*:|"<>]/g, '-') || 'l√•t'; }
            toggleScrolling() { if (this.scrollInterval) this.stopScrolling(); else this.startScrolling(); }
            // ERS√ÑTT DEN GAMLA FUNKTIONEN MED DENNA
            startScrolling() {
                // Stoppa om den redan √§r ig√•ng
                if (this.scrollInterval) return;

                // Om hastigheten √§r 0, f√∂rs√∂k att ber√§kna den nu
                if (this.scrollSpeed <= 0) {
                    this.calculateAndSetScrollSpeed();
                }

                // Kontrollera IGEN. Om hastigheten fortfarande √§r 0 (t.ex. texten √§r f√∂r kort),
                // kan vi inte starta.
                if (this.scrollSpeed <= 0) {
                    // Om du vill kan du l√§gga till en alert h√§r, men det √§r inte n√∂dv√§ndigt.
                    // this.showCustomAlert("Kan inte starta scrollningen, kontrollera tiden.");
                    return;
                }

                // NU forts√§tter vi som vanligt
                this.scrollBtnPlayPause.textContent = '‚ùö‚ùö';
                this.scrollRemainder = 0;

                const scroll = () => {
                    this.scrollRemainder += this.scrollSpeed;
                    const move = Math.floor(this.scrollRemainder);

                    if (move > 0) {
                        this.editor.scrollTop += move;
                        this.scrollRemainder -= move;
                    }

                    if (this.editor.scrollTop + this.editor.clientHeight >= this.editor.scrollHeight) {
                        this.stopScrolling();
                    } else {
                        this.scrollInterval = requestAnimationFrame(scroll);
                    }
                };
                this.scrollInterval = requestAnimationFrame(scroll);
            }

            stopScrolling() { if (this.scrollInterval) cancelAnimationFrame(this.scrollInterval); this.scrollInterval = null; this.scrollBtnPlayPause.textContent = '‚ñ∂'; }
            setScrollSpeed(value) {
                // Anv√§nd klass-egenskaperna (this.) ist√§llet f√∂r lokala konstanter
                const val = parseFloat(value);
                if (val === 0) {
                    this.scrollSpeed = 0;
                    return;
                }
                this.scrollSpeed = this.MIN_MOVE_SPEED + (val / 100) * (this.MAX_MOVE_SPEED - this.MIN_MOVE_SPEED);
            }
            getTotalDurationSeconds() { const minutes = parseInt(this.scrollDurationMinutesInput.value) || 0; const seconds = parseInt(this.scrollDurationSecondsInput.value) || 0; return (minutes * 60) + seconds; }
            updateDurationInputs(totalSeconds) { if (totalSeconds > 0) { this.scrollDurationMinutesInput.value = Math.floor(totalSeconds / 60); this.scrollDurationSecondsInput.value = totalSeconds % 60; } else { this.scrollDurationMinutesInput.value = 4; this.scrollDurationSecondsInput.value = 0; } }
            setScrollForDuration(durationSeconds) { setTimeout(() => { const scrollHeight = Math.max(1, this.editor.scrollHeight - this.editor.clientHeight); if (scrollHeight <= 0) return; const frames = Math.max(1, durationSeconds * 60); this.scrollSpeed = scrollHeight / frames; const percent = Math.round(((this.scrollSpeed - 0.02) / (0.5 - 0.02)) * 100); this.scrollSpeedSlider.value = Math.max(0, Math.min(100, percent)); }, 100); }
            updateDurationFromSpeed() { if (this.scrollSpeed < 0.001) return; const scrollHeight = Math.max(1, this.editor.scrollHeight - this.editor.clientHeight); if (scrollHeight <= 0) return; const durationSeconds = scrollHeight / (this.scrollSpeed * 60); this.updateDurationInputs(Math.round(durationSeconds)); }
        }

        window.addEventListener('load', () => new StableChordEditor('editor'));
    </script>
    </script>

    <button id="floating-live-btn" title="Starta Live-l√§ge">‚ñ∂</button>

</body>

</html>
