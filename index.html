<!DOCTYPE html>
<html lang="sv">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProChorder 9.8</title>
    <style>
      :root {
        --chord-btn-width: 65px;
        --chord-btn-height: 32px;
        --bg: #f4f5f7;
        --surface: #ffffff;
        --text-color: #172b4d;
        --primary: #1951a5;
        --border: #dfe1e6;
        --shadow: 0 4px 8px -2px rgba(9, 30, 66, 0.25),
          0 0 1px rgba(9, 30, 66, 0.31);
        --chord-color: var(--primary);
        --font-sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          "Helvetica Neue", Arial, sans-serif;
        --success-bg: #376e43;
        --danger-bg: #8d323b;
        --button-text-light: #ffffff;
        --primary-bg-hover: rgba(0, 82, 204, 0.1);
        --section-marker-color: var(--danger-bg);
        --menu-width: 320px;
      }

      body.dark-mode {
        --bg: #1d2125;
        --surface: #282d33;
        --text-color: #c1c9d3;
        --primary: #4c9aff;
        --border: #454c54;
        --chord-color: #ffcb47;
        --primary-bg-hover: rgba(76, 154, 255, 0.15);
        --section-marker-color: #ffffff;
      }

      body.dark-mode #editor a {
        color: var(--chord-color);
        text-decoration: underline;
      }

      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      body {
        font-family: var(--font-sans);
        background-color: var(--bg);
        color: var(--text-color);
        margin: 0;
        padding: 1em;
        padding-top: 70px;
        transition: background-color 0.3s, color 0.3s;
        overflow-x: hidden;
        user-select: none; /* *** NYTT: Tog detta från din prototyp, bra för en app! *** */
      }

      .top-bar {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 1em;
        padding: 10px 1em;
        background-color: var(--bg);
        z-index: 100;
        border-bottom: 1px solid var(--border);
      }

      .top-bar-left,
        /*Knapper överst*/
        .top-bar-right {
        display: flex;
        align-items: center;
        gap: 0.5em;
      }

      .top-bar-left {
        flex-grow: 1;
        min-width: 0;
      }

      #project-list {
        flex-grow: 1;
        /* Tillåt den att växa */
        min-width: 140px;
        /* Men aldrig bli mindre än så här */
        max-width: 450px;
        /* Och aldrig bli större än så här */
      }

      .top-bar select,
      .top-bar button {
        border: 1px solid var(--border);
        background-color: var(--surface);
        color: var(--text-color);
        border-radius: 8px;
        box-shadow: 0 1px 1px rgba(9, 30, 66, 0.25),
          0 0 1px rgba(9, 30, 66, 0.31);
        font-size: 1em;
        height: 33px;
        box-sizing: border-box;
      }

      .top-bar button {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 33px;
        padding: 0;
        font-size: 1.2em;
        flex-shrink: 0;
        cursor: pointer;
        font-weight: 700;
      }

      .top-bar select {
        padding: 0 0.75em;
      }

      #hamburger-btn {
        font-size: 24px;
        font-weight: normal;
      }

      #btn-toggle-dark-mode {
        font-size: 1.5em;
      }

      #side-menu {
        position: fixed;
        top: 0;
        right: 0;
        height: 100%;
        width: var(--menu-width);
        max-width: 90%;
        background-color: var(--surface);
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
        z-index: 1001;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 1em;
        padding: 1.5em;
      }

      #side-menu:not(.is-closed) {
        transform: translateX(0);
      }

      #menu-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(9, 30, 66, 0.5);
        z-index: 1000;
        opacity: 1;
        transition: opacity 0.3s ease-in-out;
      }

      #menu-overlay.is-closed {
        opacity: 0;
        pointer-events: none;
      }

      .container {
        max-width: 1280px;
        margin: 0 auto;
      }

      .app-layout {
        display: flex;
        flex-direction: column;
        gap: 1em;
      }

      .sidebar-group {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 8px;
      }

      .sidebar-group-label {
        position: relative;
        cursor: pointer;
        padding: 0.8em;
        user-select: none;
        font-weight: 700;
        display: block;
      }

      .sidebar-group-label::after {
        content: "›";
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%) rotate(0deg);
        transition: transform 0.3s ease;
        font-size: 1.5em;
      }

      .sidebar-group-label.is-open::after {
        transform: translateY(-50%) rotate(90deg);
      }

      .sidebar-group-content {
        overflow: hidden;
        max-height: 500px;
        transition: max-height 0.4s ease-in-out, padding 0.3s ease-out;
        padding: 0 1em 1em 1em;
      }

      .sidebar-group-content.is-collapsed {
        max-height: 0;
        padding-top: 0;
        padding-bottom: 0;
        visibility: hidden;
      }

      .sidebar-controls {
        display: flex;
        flex-direction: column;
        gap: 0.8em;
        padding-top: 0;
      }

      .sidebar-controls.horizontal {
        flex-direction: row;
        align-items: center;
        gap: 0.4em;
      }

      .sidebar-controls span {
        font-size: 0.8em;
        margin-right: 0.2em;
        white-space: nowrap;
      }

      #side-menu button,
      #side-menu select,
      #side-menu input {
        font-family: var(--font-sans);
        font-weight: 600;
        font-size: 0.85em;
        height: 33px;
        background-color: var(--bg);
        color: var(--text-color);
        border: 1px solid var(--border);
        border-radius: 6px;
        cursor: pointer;
        padding: 0 0.7em;
        box-sizing: border-box;
        width: 70%;
      }

      #side-menu #song-title {
        font-weight: 700;
      }

      .sidebar-controls.horizontal > * {
        flex: 1;
      }

      #side-menu button:hover {
        transform: translateY(1px);
        border-color: var(--primary);
      }

      #side-menu button.btn-primary {
        background-color: var(--primary);
        color: var(--button-text-light);
      }

      #side-menu button.btn-success {
        background-color: var(--success-bg);
        color: var(--button-text-light);
      }

      #side-menu button.btn-danger {
        background-color: var(--danger-bg);
        color: var(--button-text-light);
      }

      #side-menu input[type="range"] {
        height: auto;
      }

      .main-content {
        flex-basis: 0;
        flex-grow: 999;
        min-width: 60%;
        display: flex;
        flex-direction: column;
        gap: 1em;
      }

      #editor {
        background-color: var(--surface);
        border: 1px solid var(--border);
        padding: 0.5em;
        border-radius: 8px;
        box-shadow: 0 1px 1px rgba(9, 30, 66, 0.25),
          0 0 1px rgba(9, 30, 66, 0.31);
        height: calc(100vh - 90px);
        font-family: var(--font-sans);
        line-height: 1.9;
        outline: none;
        font-size: 16px;
        overflow-y: scroll;
        clear: both;
        width: 100%;
      }

      #editor a {
        cursor: pointer;
      }

      #editor > div:not(:has(.section-marker)) {
        line-height: 2.5;
      }

      #editor:focus-within {
        border-color: var(--primary);
      }

      #editor > div {
        position: relative;
      }

      #editor .chord {
        display: inline-block;
        position: relative;
        user-select: none;
        cursor: default;
        vertical-align: middle;
        top: -1.7em;
        /* ................Ackord avstånd till text..........*/
        height: 0;
        width: 0;
        padding: 0;
        margin: 0;
        z-index: 5;
      }

      #editor .chord:hover {
        background-color: var(--primary-bg-hover);
        z-index: 10;
      }

      #editor .chord-text {
        position: absolute;
        left: 0;
        display: inline-block;
        font-family: var(--font-sans);
        font-weight: 600;
        font-size: 0.85em;
        color: var(--chord-color);
        line-height: 1.2;
        min-width: 1ch;
        outline: none;
        padding: 0.1em 0.4em;
        border-radius: 3px;
        white-space: nowrap;
      }

      #editor .chord-handle {
        position: absolute;
        bottom: 0px;
        left: 50%;
        transform: translateX(-50%);
        width: 20px;
        height: 10px;
        background-color: var(--primary);
        border-radius: 3px;
        cursor: grab;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
      }

      #editor .chord:hover .chord-handle {
        opacity: 1;
        pointer-events: auto;
      }

      #editor .section-marker {
        display: block;
        margin-bottom: 0.25em;
        line-height: 2.5;
        font-weight: 700;
        font-size: 1.1em;
        color: var(--text-color);
        background-color: transparent;
        padding: 0;
        user-select: none;
      }

      #editor.text-mode .chord-handle {
        display: none !important;
      }

      #editor.text-mode .chord {
        opacity: 0.6;
      }

      body.scroll-mode-active #editor {
        caret-color: transparent;
        border-color: transparent;
        box-shadow: none;
      }

      .custom-dialog-overlay,
      #scroll-controls {
        z-index: 2000;
      }

      .custom-dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.2s, visibility 0.2s;
      }

      .custom-dialog-overlay.visible {
        opacity: 1;
        visibility: visible;
      }

      .custom-dialog-box {
        background-color: var(--surface);
        color: var(--text-color);
        padding: 2em;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        text-align: center;
        min-width: 300px;
        max-width: 90%;
      }

      .custom-dialog-box .dialog-buttons {
        display: flex;
        gap: 1em;
        justify-content: center;
        margin-top: 1.5em;
      }

      .custom-dialog-box button {
        min-width: 100px;
        height: 38px;
        border: none;
        border-radius: 6px;
        font-weight: 600;
        cursor: pointer;
      }

      .custom-dialog-box button.btn-primary {
        background-color: var(--primary);
        color: var(--button-text-light);
      }

      /* Ny stil för siffer-rutorna i live-läget */
      #scroll-controls input[type="number"] {
        background-color: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--button-text-light);
        border-radius: 8px;
        height: 38px;
        width: 60px;
        font-size: 1.2em;
        font-weight: 700;
        text-align: center;
        -moz-appearance: textfield;
        /* Döljer pilarna i Firefox */
      }

      /* Döljer upp/ner-pilarna i Chrome, Safari, etc. */
      #scroll-controls input[type="number"]::-webkit-outer-spin-button,
      #scroll-controls input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }

      #drop-indicator {
        position: absolute;
        width: 2px;
        height: 1.8em;
        background-color: var(--primary);
        display: none;
        pointer-events: none;
        z-index: 9999;
      }

      body.is-dragging * {
        cursor: none !important;
      }

      #scroll-controls {
        /* Positionering och grundläggande layout */
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        padding: 0.8em 1em;
        z-index: 2000;

        /* Den nya "glas-stilen" */
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px);
        border-top: 1px solid rgba(255, 255, 255, 0.1);

        /* Grid-layout för innehållet */
        grid-template-columns: auto 1fr auto;
        grid-template-rows: auto auto;
        align-items: center;
        gap: 0.75em 1em;
      }

      #scroll-btn-play-pause,
      #scroll-btn-exit {
        background-color: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--button-text-light);
        border-radius: 8px;
        height: 38px;
        width: 60px;
        font-size: 1.2em;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      #scroll-btn-play-pause:hover,
      #scroll-btn-exit:hover {
        background-color: rgba(255, 255, 255, 0.3);
      }

      body.scroll-mode-active #scroll-controls {
        display: grid;
      }

      #scroll-controls .speed-control {
        grid-column: 1 / -1;
        grid-row: 1;
        display: flex;
        align-items: center;
        gap: 0.5em;
      }

      #scroll-btn-play-pause {
        grid-column: 1;
        grid-row: 2;
      }

      #scroll-controls .duration-control {
        grid-column: 2;
        grid-row: 2;
        justify-self: center;
        display: flex;
        align-items: center;
        gap: 0.5em;
      }

      #scroll-btn-exit {
        grid-column: -3;
        grid-row: 2;
        /*justify-self: flex-end; Lägger stopp-knapp till höger*/
      }

      body.scroll-mode-active #editor {
        caret-color: transparent;
        border-color: transparent;
        box-shadow: none;
      }

      .chord-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, var(--chord-btn-width));
        gap: 6px;
        justify-content: center;
        margin-top: 1em;
      }

      .chord-grid button {
        all: unset;
        display: flex;
        align-items: center;
        justify-content: center;
        width: var(--chord-btn-width);
        height: var(--chord-btn-height);
        box-sizing: border-box;
        border: 1px solid var(--border);
        border-radius: 6px;
        font-family: var(--font-sans);
        font-size: 0.85em;
        font-weight: 600;
        background-color: var(--bg);
        color: var(--text-color);
        cursor: pointer;
        transition: background-color 0.2s, border-color 0.2s;
      }

      .chord-grid button:hover {
        background-color: var(--primary-bg-hover);
        border-color: var(--primary);
      }

      .chord-grid button.active {
        background-color: var(--primary);
        color: var(--button-text-light);
        border-color: var(--primary);
      }

      .hidden-file {
        display: none;
      }

      #floating-live-btn {
        position: fixed;
        bottom: 24px;
        right: 20px;
        width: 45px;
        height: 45px;
        border-radius: 50%;
        background-color: var(--primary);
        color: var(--button-text-light);
        border: none;
        font-size: 0.8em;
        /* Gör play-symbolen lite större */
        font-weight: 700;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow);
        z-index: 100;
        /* Ser till att den ligger ovanpå texten */
        transition: transform 0.2s ease-out, opacity 0.3s ease;
      }

      #floating-live-btn:hover {
        transform: scale(1.05);
        /* En trevlig effekt när man hovrar */
      }

      /* Dölj knappen när scroll-läget redan är aktivt */
      body.scroll-mode-active #floating-live-btn {
        opacity: 0;
        pointer-events: none;
        /* Gör den oklickbar när den är osynlig */
        transform: scale(0.8);
      }

      /* *** ALL NY CSS FÖR DEN RADIALA BYGGAREN *** */
      /* (Inkluderar CSS från din prototyp) */

      /* Ändrar den yttre boxen så den blir "osynlig" och bara centrerar innehållet */
      #chord-editor-modal .custom-dialog-box {
        background: transparent;
        box-shadow: none;
        padding: 0;
        color: white; /* Textfärg för den nya byggaren */
        min-width: 320px; /* Sätter en basstorlek */
        width: 320px;
      }

      .chord-selector-container {
        position: relative;
        width: 320px;
        height: 320px;
        border-radius: 50%;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
        margin: 0 auto;
      }

      /* Allmän stil för lagren */
      .layer {
        position: absolute;
        top: 0;
        left: 0;
        border-radius: 50%;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: transform 0.3s ease; /* Jämnare rotation */
        cursor: pointer;
      }

      /* 1. Yttre lagret (Bas-ton/Inversion) */
      .layer-outer {
        width: 100%;
        height: 100%;
        background-color: rgba(255, 255, 255, 0.05);
        font-size: 1.1em;
      }

      /* 2. Mellersta lagret (Färgning/Typ) */
      .layer-middle {
        width: 75%; /* <-- Ändrad från 70% */
        height: 75%; /* <-- Ändrad från 70% */
        margin: 12.5%; /* <-- Ändrad från 15% (100-75)/2 */
        background-color: rgba(255, 255, 255, 0.1);
        font-size: 0.9em;
      }

      /* Ersätt med detta: */
      .layer-inner {
        width: 50%; /* <-- Ändrad från 40% */
        height: 50%; /* <-- Ändrad från 40% */
        margin: 25%; /* <-- Ändrad från 30% (100-50)/2 */
        background-color: rgba(255, 255, 255, 0.2);
        font-size: 0.7;
      }

      /* Objekt på lagren (valalternativ) */
      /* Ersätt med detta: */
      .layer-item {
        position: absolute;
        width: 36px; /* <-- Fast bredd */
        height: 36px; /* <-- Fast höjd */
        display: flex; /* <-- Centrerar texten i knappen */
        align-items: center;
        justify-content: center;
        font-weight: bold;
        border-radius: 50%; /* <-- Gör knappen rund */
        background-color: rgba(0, 0, 0, 0.1); /* <-- Visar knappens yta */
        transition: background-color 0.2s;
      }

      .layer-item:hover {
        background-color: rgba(255, 255, 255, 0.2); /* Effekt för muspekare */
      }

      /* Visuell markör för valt objekt */
      .layer-item.active {
        color: #2ecc71; /* Grön färg för aktiva val */
        text-shadow: 0 0 5px rgba(46, 204, 113, 0.8);
        background-color: rgba(0, 0, 0, 0.2);
      }

      /* Mittknappen (Bekräfta och Visa) */
      .center-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        border-radius: 50%;
        background-color: #e74c3c; /* Röd färg (ej bekräftad) */
        color: white;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        text-align: center;
        font-weight: bold;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        transition: background-color 0.1s;
        z-index: 10;
      }

      .center-button.confirmed {
        background-color: #2ecc71; /* Grön färg (bekräftad) */
      }

      .center-button:active {
        transform: translate(-50%, -50%) scale(0.95);
      }

      .current-chord-display {
        font-size: 1.2em;
        margin-bottom: 3px;
      }

      .action-text {
        font-size: 0.7em;
        opacity: 0.8;
      }

      /* Behållaren för de gamla knapparna (Ta bort/Stäng) */
      #chord-editor-modal .dialog-buttons {
        display: flex;
        justify-content: center; /* <-- ÄNDRAD FRÅN space-between */
        gap: 1em; /* <-- TILLAGD för lite luft */
        margin-top: 1.5em;
        background: var(--surface);
        padding: 1em;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }

      /* *** SLUT PÅ NY CSS *** */
    </style>
  </head>

  <body>
    <div class="top-bar">
      <div class="top-bar-left">
        <select id="project-list"></select>
        <button id="btn-new-project" class="btn-primary" title="New Project">
          +
        </button>
      </div>
      <div class="top-bar-right">
        <button id="main-toggle-edit-mode-btn" title="Växla Redigeringsläge">
          A
        </button>
        <button id="btn-show-help" title="Hjälp & HOW TO">?</button>
        <button id="btn-toggle-dark-mode" title="Växla ljust/mörkt läge">
          🌙
        </button>
        <button id="hamburger-btn">☰</button>
      </div>
    </div>

    <div id="menu-overlay" class="is-closed"></div>

    <nav id="side-menu" class="is-closed">
      <input type="text" id="song-title" placeholder="Title" />
      <input type="text" id="song-author" placeholder="Artist / Song writer" />
      <button id="btn-toggle-scroll-mode" class="btn-primary">LIVE!</button>

      <div class="sidebar-group">
        <span class="sidebar-group-label" id="edit-mode-label">Redigera</span>
        <div class="sidebar-group-content is-collapsed">
          <div class="sidebar-controls vertical">
            <button
              id="btn-toggle-edit-mode"
              title="Växla mellan text- och ackordläge"
            >
              Byt läge
            </button>
            <div class="sidebar-controls horizontal">
              <button id="btn-transpose-up">+1</button>
              <button id="btn-transpose-down">-1</button>
            </div>
            <div class="sidebar-controls horizontal">
              <span>Font size</span>
              <input
                type="range"
                id="font-size-slider"
                min="12"
                max="32"
                value="16"
              />
            </div>
          </div>
        </div>
      </div>
      <div class="sidebar-group">
        <span class="sidebar-group-label">Sections</span>
        <div class="sidebar-group-content is-collapsed">
          <div class="sidebar-controls horizontal">
            <select id="section-type-select-menu"></select>
            <button id="btn-insert-section">Insert</button>
          </div>
        </div>
      </div>
      <div class="sidebar-group">
        <span class="sidebar-group-label">Project</span>
        <div class="sidebar-group-content is-collapsed">
          <div class="sidebar-controls vertical">
            <button id="btn-save-project" class="btn-success">Save</button>
            <button id="btn-delete-project" class="btn-danger">Remove</button>
            <button id="btn-delete-all-projects" class="btn-danger">
              Erase all
            </button>
          </div>
        </div>
      </div>
      <div class="sidebar-group">
        <span class="sidebar-group-label">Import/Export</span>
        <div class="sidebar-group-content is-collapsed">
          <div class="sidebar-controls vertical" style="gap: 0.5em">
            <div class="sidebar-controls horizontal">
              <button id="btn-export-pdf">PDF</button>
              <button id="btn-export-txt">TXT</button>
              <button id="btn-export-zip">ZIP</button>
            </div>
            <div class="sidebar-controls horizontal">
              <button id="btn-export-json">Song->JSON</button>
              <button id="btn-export-all-json">All->JSON</button>
            </div>
            <div class="sidebar-controls horizontal">
              <button id="btn-import-json">Imp.->JSON</button>
              <button id="btn-import-url" class="btn-primary">
                Import URL
              </button>
            </div>
            <input
              type="file"
              id="file-import"
              accept="application/json"
              class="hidden-file"
            />
          </div>
        </div>
      </div>
    </nav>

    <div class="container">
      <div class="app-layout">
        <main class="main-content">
          <div id="editor" contenteditable="true" spellcheck="false"></div>
        </main>
      </div>
    </div>

    <div id="scroll-controls">
      <button id="scroll-btn-play-pause">▶</button>
      <div class="speed-control">
        <span>Slow</span>
        <input
          type="range"
          id="scroll-speed-slider"
          min="0"
          max="100"
          value="20"
        />
        <span>Fast</span>
      </div>
      <div class="duration-control">
        <label></label>
        <input
          type="number"
          id="scroll-duration-minutes"
          min="0"
          max="60"
          value="4"
        />
        <span>m</span>
        <input
          type="number"
          id="scroll-duration-seconds"
          min="0"
          max="59"
          step="5"
          value="0"
        />
        <span>s</span>
      </div>
      <button id="scroll-btn-exit">Exit</button>
    </div>

    <div id="custom-alert" class="custom-dialog-overlay">
      <div class="custom-dialog-box">
        <p id="custom-alert-message"></p>
        <div class="dialog-buttons">
          <button id="custom-alert-ok" class="btn-primary">OK</button>
        </div>
      </div>
    </div>
    <div id="custom-confirm" class="custom-dialog-overlay">
      <div class="custom-dialog-box">
        <p id="custom-confirm-message"></p>
        <div class="dialog-buttons">
          <button id="custom-confirm-cancel">Cancel</button>
          <button id="custom-confirm-ok" class="btn-danger">OK</button>
        </div>
      </div>
    </div>

    <div id="chord-editor-modal" class="custom-dialog-overlay">
      <div class="custom-dialog-box">
        <div class="chord-selector-container">
          <div id="outer-layer" class="layer layer-outer"></div>
          <div id="middle-layer" class="layer layer-middle"></div>
          <div id="inner-layer" class="layer layer-inner"></div>
          <div id="center-button" class="center-button">
            <div id="current-chord-display" class="current-chord-display">
              C
            </div>
            <div id="action-text" class="action-text">USE</div>
          </div>
        </div>

        <div class="dialog-buttons">
          <button id="modal-btn-remove" class="btn-danger">
            Ta bort ackord
          </button>
          <button id="modal-btn-close">Stäng</button>
        </div>
      </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <script>
      // ... Javascriptet är nästan helt oförändrat, men klistrar in hela för att vara säker.
      // Relevanta ändringar är markerade.

      const SHARED_SONG_LIST_URL =
        "https.raw.githubusercontent.com/Gobonkers65/ProChorder/main/songs-backup.json";

      class StableChordEditor {
        static STORAGE_KEYS = {
          PROJECTS: "stableProjects",
          LAST_PROJECT: "lastProject",
          DARK_MODE: "darkMode",
        };
        // *** LÄGG TILL HELA DENNA NYA FUNKTION ***
        // ERSÄTT HELA DIN GAMLA handleAutoLinking-FUNKTION MED DENNA NYA
        // ERSÄTT HELA DIN GAMLA handleAutoLinking-FUNKTION MED DENNA FÖRBÄTTRADE VERSION
        handleAutoLinking(e) {
          if (e.key !== " " && e.key !== "Enter") return;

          const selection = window.getSelection();
          if (!selection.rangeCount || !selection.isCollapsed) return;

          const range = selection.getRangeAt(0);
          const container = range.startContainer;
          if (container.nodeType !== Node.TEXT_NODE) return;

          const textContent = container.textContent.substring(
            0,
            range.startOffset
          );

          // -- MER ROBUST REGEX HÄR --
          const customLinkRegex = /\[\[(.+?)(?:\|(.*?))?\]\]\s*$/;
          const autoLinkRegex =
            /(?:^|\s)((?:https?:\/\/\S+|(?:www|ftp)\.\S+))\s*$/;

          const customMatch = textContent.match(customLinkRegex);
          const autoMatch = !customMatch && textContent.match(autoLinkRegex); // Kör bara auto om custom misslyckas

          let url, linkText, startIndex, fullMatchLength;

          if (customMatch) {
            url = customMatch[1].trim();
            linkText = (customMatch[2] || "").trim() || url; // Använd text om den finns, annars URL
            const fullMatchString = customMatch[0].trimEnd();
            startIndex = textContent.lastIndexOf(fullMatchString);
            fullMatchLength = fullMatchString.length;
          } else if (autoMatch) {
            url = autoMatch[1];
            linkText = url;
            startIndex = textContent.lastIndexOf(url);
            fullMatchLength = url.length;
          } else {
            return; // Ingen matchning
          }

          if (!url || startIndex === -1) return; // Säkerhetskoll

          e.preventDefault(); // Förhindra att mellanslag/enter skrivs ut

          const replaceRange = document.createRange();
          replaceRange.setStart(container, startIndex);
          replaceRange.setEnd(container, startIndex + fullMatchLength);
          replaceRange.deleteContents();

          const link = document.createElement("a");
          link.href =
            url.startsWith("http") || url.startsWith("//")
              ? url
              : `http://${url}`;
          link.textContent = linkText;
          link.target = "_blank";
          link.rel = "noopener noreferrer";
          replaceRange.insertNode(link);

          // Återställ markören efter den nya länken
          range.setStartAfter(link);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);

          this.recordHistoryDebounced();
        }

        constructor(editorId) {
          this.editor = document.getElementById(editorId);
          this.editMode = "chord";
          this.draggedChord = null;
          this.scrollInterval = null;
          this.scrollSpeed = 0.2;
          this.history = [];
          this.historyIndex = -1;
          this.debounceTimer = null;
          this.currentlyEditing = null;
          this.musicalNotes = [
            "A",
            "A#",
            "B",
            "C",
            "C#",
            "D",
            "D#",
            "E",
            "F",
            "F#",
            "G",
            "G#",
          ];
          // *** ÄNDRAD: Bytt namn på bassNotes för att undvika konflikt. ***
          this.chordBasisNotes = [
            "A",
            "A#",
            "B",
            "C",
            "C#",
            "D",
            "D#",
            "E",
            "F",
            "F#",
            "G",
            "G#",
          ];
          // *** ÄNDRAD: Använder en tom sträng för "dur" (maj). ***
          this.chordTypes = [
            "",
            "m",
            "7",
            "m7",
            "maj7",
            "dim",
            "aug",
            "sus2",
            "sus4",
            "6",
            "9",
            "11",
          ];
          this.historyMax = 100;
          this.MIN_MOVE_SPEED = 0.02;
          this.MAX_MOVE_SPEED = 0.5;

          // *** NYTT: Egenskaper för den radiala byggaren (från din prototyp) ***
          this.radialTypes = [
            "",
            "m",
            "6",
            "7",
            "9",
            "11",
            "maj7",
            "m7",
            "sus4",
            "dim",
            "aug",
          ]; // Ett urval av de vanligaste
          this.radialBassNotes = [
            "(root)",
            "A",
            "A#",
            "B",
            "C",
            "C#",
            "D",
            "D#",
            "E",
            "F",
            "F#",
            "G",
            "G#",
          ]; // "(root)" betyder ingen baston
          this.radialState = {
            root: "C",
            type: "", // "" (tom sträng) är "maj"
            base: "(root)",
            rootIndex: 3, // 'C' är index 3 i musicalNotes
            typeIndex: 0,
            baseIndex: 0,
          };
          // *** SLUT PÅ NYTT ***

          this.selectElements();
          this.wakeLock = null; // För skärmlåset
          this.observer = new MutationObserver(this.handleMutations.bind(this));
          this.init();
        }

        selectElements() {
          this.hamburgerBtn = document.getElementById("hamburger-btn");
          this.sideMenu = document.getElementById("side-menu");
          this.menuOverlay = document.getElementById("menu-overlay");
          this.container = document.querySelector(".container");
          this.titleInput = document.getElementById("song-title");
          this.authorInput = document.getElementById("song-author");
          this.editModeLabel = document.getElementById("edit-mode-label");
          this.btnToggleEditMode = document.getElementById(
            "btn-toggle-edit-mode"
          );

          this.mainToggleEditModeBtn = document.getElementById(
            "main-toggle-edit-mode-btn"
          );

          this.btnToggleScrollMode = document.getElementById(
            "btn-toggle-scroll-mode"
          );
          this.sectionTypeSelect = document.getElementById(
            "section-type-select-menu"
          );
          this.btnInsertSection = document.getElementById("btn-insert-section");
          this.fontSizeSlider = document.getElementById("font-size-slider");
          this.projectList = document.getElementById("project-list");
          this.btnNewProject = document.getElementById("btn-new-project");
          this.btnSaveProject = document.getElementById("btn-save-project");
          this.btnDeleteProject = document.getElementById("btn-delete-project");
          this.btnDeleteAllProjects = document.getElementById(
            "btn-delete-all-projects"
          );
          this.btnTransposeUp = document.getElementById("btn-transpose-up");
          this.btnTransposeDown = document.getElementById("btn-transpose-down");
          this.btnExportPdf = document.getElementById("btn-export-pdf");
          this.btnExportTxt = document.getElementById("btn-export-txt");
          this.btnExportZip = document.getElementById("btn-export-zip");
          this.btnToggleDarkMode = document.getElementById(
            "btn-toggle-dark-mode"
          );
          this.btnShowHelp = document.getElementById("btn-show-help");
          this.btnExportJson = document.getElementById("btn-export-json");
          this.btnExportAllJson = document.getElementById(
            "btn-export-all-json"
          );
          this.btnImportJson = document.getElementById("btn-import-json");
          this.fileImport = document.getElementById("file-import");
          this.btnImportUrl = document.getElementById("btn-import-url");
          this.chordEditorModal = document.getElementById("chord-editor-modal");

          // *** ÄNDRAD: Tar bort referenser till det gamla rutnätet ***
          // this.modalChordTarget = document.getElementById('modal-chord-target');
          // this.modalRootNotes = document.getElementById('modal-root-notes');
          // this.modalChordTypes = document.getElementById('modal-chord-types');
          // this.modalBassNotes = document.getElementById('modal-bass-notes');
          // this.modalBtnDone = document.getElementById('modal-btn-done');

          // Dessa knappar finns kvar, men i en ny position
          this.modalBtnRemove = document.getElementById("modal-btn-remove");
          this.modalBtnClose = document.getElementById("modal-btn-close");

          this.scrollControls = document.getElementById("scroll-controls");
          this.scrollBtnPlayPause = document.getElementById(
            "scroll-btn-play-pause"
          );
          this.scrollBtnExit = document.getElementById("scroll-btn-exit");
          this.scrollSpeedSlider = document.getElementById(
            "scroll-speed-slider"
          );
          this.scrollDurationMinutesInput = document.getElementById(
            "scroll-duration-minutes"
          );
          this.scrollDurationSecondsInput = document.getElementById(
            "scroll-duration-seconds"
          );
          this.dropIndicator = document.createElement("div");
          this.dropIndicator.id = "drop-indicator";
          document.body.appendChild(this.dropIndicator);
          this.floatingLiveBtn = document.getElementById("floating-live-btn");
        }

        init() {
          this.populateSelects();
          this.applySavedTheme();
          this.setupEventListeners();
          this.updateModeUI();
          this.setScrollSpeed(this.scrollSpeedSlider.value);
          this.updateDurationFromSpeed();
          this.startObserver();
          this.loadLastProject();
        }

        populateSelects() {
          const sectionData = [
            "Intro",
            "Verse",
            "Chorus",
            "Stick",
            "Bridge",
            "Solo",
            "Outro",
            "Dig",
          ];
          const populate = (sel, options, placeholder) => {
            if (!sel) return;
            sel.innerHTML = `<option value="" disabled selected>${placeholder}</option>`;
            options.forEach(
              (o) => (sel.innerHTML += `<option value="${o}">${o}</option>`)
            );
          };
          populate(this.sectionTypeSelect, sectionData, "Select Section...");
        }

        applySavedTheme() {
          const isDarkMode =
            localStorage.getItem(StableChordEditor.STORAGE_KEYS.DARK_MODE) ===
            "enabled";
          if (isDarkMode) {
            document.body.classList.add("dark-mode");
            this.btnToggleDarkMode.textContent = "☀️";
          } else {
            document.body.classList.remove("dark-mode");
            this.btnToggleDarkMode.textContent = "🌙";
          }
        }

        startObserver() {
          this.observer.observe(this.editor, {
            childList: true,
            subtree: true,
            characterData: true,
          });
        }

        stopObserver() {
          this.observer.disconnect();
        }

        toggleEditMode() {
          this.editMode = this.editMode === "chord" ? "text" : "chord";
          this.updateModeUI();
        }

        // *** NYA FUNKTIONER FÖR SKÄRMLÅS ***
        async acquireWakeLock() {
          if ("wakeLock" in navigator) {
            try {
              this.wakeLock = await navigator.wakeLock.request("screen");
              console.log("Skärmlås aktiverat!");
              this.wakeLock.addEventListener("release", () => {
                console.log("Skärmlås släppt (t.ex. flik dold)");
                this.wakeLock = null;
              });
            } catch (err) {
              console.error(
                `Kunde inte skaffa skärmlås: ${err.name}, ${err.message}`
              );
            }
          } else {
            console.warn("Wake Lock API stöds inte i denna webbläsare.");
          }
        }

        async releaseWakeLock() {
          if (this.wakeLock !== null) {
            try {
              await this.wakeLock.release();
              this.wakeLock = null;
              console.log("Skärmlås släppt.");
            } catch (err) {
              console.error(
                `Kunde inte släppa skärmlås: ${err.name}, ${err.message}`
              );
            }
          }
        }

        handleVisibilityChange() {
          if (
            this.editMode === "scroll" &&
            document.visibilityState === "visible" &&
            !this.wakeLock
          ) {
            console.log("Fliken synlig, försöker återta skärmlås...");
            this.acquireWakeLock();
          }
        }
        // *** SLUT PÅ SKÄRMLÅS-FUNKTIONER ***

        setupEventListeners() {
          this.floatingLiveBtn.addEventListener("click", () => {
            this.toggleScrollMode(true, true);
          });
          const toggleMenu = () => {
            this.sideMenu.classList.toggle("is-closed");
            this.menuOverlay.classList.toggle("is-closed");
          };
          this.hamburgerBtn.addEventListener("click", toggleMenu);
          this.menuOverlay.addEventListener("click", toggleMenu);

          this.titleInput.addEventListener("blur", async () => {
            const oldName = this.projectList.value;
            const newName = this.titleInput.value.trim();
            if (oldName && newName && oldName !== newName) {
              const confirmed = await this.showCustomConfirm(
                `Do you want to rename this project "${oldName}" till "${newName}"?`
              );
              if (confirmed) {
                this.renameProject(oldName, newName);
              } else {
                this.titleInput.value = oldName;
              }
            }
          });

          this.btnToggleEditMode.addEventListener("click", () =>
            this.toggleEditMode()
          );
          this.mainToggleEditModeBtn.addEventListener("click", () =>
            this.toggleEditMode()
          );

          this.btnToggleScrollMode.addEventListener("click", () => {
            this.toggleScrollMode(true);
            if (!this.sideMenu.classList.contains("is-closed")) {
              toggleMenu();
            }
          });

          // *** ÄNDRAD: Lyssnare för den nya byggarens knappar ***
          this.modalBtnClose.addEventListener("click", () =>
            this.closeChordModal()
          );
          this.modalBtnRemove.addEventListener("click", () =>
            this.removeChord()
          );

          // *** NYTT: Lyssnare för den radiala mittknappen ***
          document
            .getElementById("center-button")
            .addEventListener("click", () => {
              const finalChord = document.getElementById(
                "current-chord-display"
              ).textContent;

              document
                .getElementById("center-button")
                .classList.add("confirmed");
              document.getElementById("action-text").textContent = `USED`;

              // Anropa den befintliga klassmetoden för att infoga ackordet
              // Denna metod stänger också modalen automatiskt
              this.applyChord(finalChord);

              // Återställ knappen efter en kort stund
              setTimeout(() => {
                if (document.getElementById("action-text")) {
                  document.getElementById("action-text").textContent = `USE`;
                  document
                    .getElementById("center-button")
                    .classList.remove("confirmed");
                }
              }, 800);
            });
          // *** SLUT PÅ NYTT ***

          this.scrollBtnExit.addEventListener("click", () =>
            this.toggleScrollMode(false)
          );

          this.editor.addEventListener("click", (e) => {
            const link = e.target.closest("a");
            if (link && link.href) {
              e.preventDefault();
              window.open(link.href, "_blank");
              return;
            }
            if (this.editMode !== "chord") return;
            const clickedChord = e.target.closest(".chord");
            if (clickedChord) {
              this.openChordModal(clickedChord, null);
            } else {
              const range = this.getWordAtCursor(e);
              if (range) this.openChordModal(null, range);
            }
          });
          this.editor.addEventListener(
            "keydown",
            this.handleKeyDown.bind(this)
          );
          this.editor.addEventListener("paste", (e) => {
            e.preventDefault();
            const text = (e.clipboardData || window.clipboardData).getData(
              "text/plain"
            );
            document.execCommand("insertText", false, text);
          });
          this.editor.addEventListener("input", () =>
            this.recordHistoryDebounced()
          );
          this.editor.addEventListener(
            "keyup",
            this.handleAutoLinking.bind(this)
          );
          document.querySelectorAll(".sidebar-group-label").forEach((label) => {
            label.addEventListener("click", () => {
              const content = label.nextElementSibling;
              const wasOpen = label.classList.contains("is-open");

              label
                .closest("#side-menu")
                .querySelectorAll(".sidebar-group-label")
                .forEach((otherLabel) => {
                  otherLabel.classList.remove("is-open");
                  otherLabel.nextElementSibling.classList.add("is-collapsed");
                });

              if (!wasOpen) {
                label.classList.add("is-open");
                content.classList.remove("is-collapsed");
              }
            });
          });

          this.editor.addEventListener(
            "dragover",
            this.handleDragOver.bind(this)
          );
          this.editor.addEventListener(
            "dragleave",
            () => (this.dropIndicator.style.display = "none")
          );
          this.editor.addEventListener("drop", this.handleDrop.bind(this));
          this.projectList.addEventListener("change", () => {
            const name = this.projectList.value || "";
            if (name) {
              this.loadProject(name);
            }
          });
          this.btnNewProject.addEventListener("click", async () => {
            if (
              await this.showCustomConfirm(
                "Are you sure? Unsaved changes will be lost!."
              )
            ) {
              this.createNewProject();
            }
          });
          this.btnSaveProject.addEventListener("click", () => {
            const name = this.titleInput.value.trim();
            if (!name) return this.showCustomAlert("Name your song.");
            this.saveProject(name);
          });
          this.btnDeleteProject.addEventListener("click", async () => {
            const name = this.projectList.value;
            if (!name)
              return this.showCustomAlert("Select a project to remove.");
            if (
              await this.showCustomConfirm(
                `Delete projeckt "${name}"? This cannot be undone!`
              )
            )
              this.deleteProject(name);
          });
          this.btnDeleteAllProjects.addEventListener("click", () =>
            this.deleteAllProjects()
          );
          this.btnTransposeUp.addEventListener("click", () =>
            this.transpose(1)
          );
          this.btnTransposeDown.addEventListener("click", () =>
            this.transpose(-1)
          );
          this.fontSizeSlider.addEventListener(
            "input",
            (e) => (this.editor.style.fontSize = e.target.value + "px")
          );
          this.btnExportPdf.addEventListener("click", () => this.exportPdf());
          this.btnExportTxt.addEventListener("click", () => this.exportTxt());
          this.btnExportZip.addEventListener("click", () =>
            this.exportAllAsZip()
          );
          this.btnToggleDarkMode.addEventListener("click", () =>
            this.toggleDarkMode()
          );
          this.btnShowHelp.addEventListener("click", () => {
            window.open(
              "https.gobonkers65.github.io/ProChorder/help",
              "_blank"
            );
          });
          this.btnExportJson.addEventListener("click", () => this.exportJson());
          this.btnExportAllJson.addEventListener("click", () =>
            this.exportAllJson()
          );
          this.btnImportJson.addEventListener("click", () =>
            this.fileImport.click()
          );
          this.fileImport.addEventListener("change", (e) =>
            this.importJsonFromFile(e.target.files[0])
          );
          this.btnImportUrl.addEventListener("click", async () => {
            const confirmed = await this.showCustomConfirm(
              "Ladda låtlista från GitHub? Lokala låtar med samma titel skrivs över."
            );
            if (confirmed) this.importJsonFromUrl(SHARED_SONG_LIST_URL);
          });
          this.scrollBtnPlayPause.addEventListener("click", () =>
            this.toggleScrolling()
          );
          this.scrollSpeedSlider.addEventListener("input", (e) => {
            this.setScrollSpeed(e.target.value);
            this.updateDurationFromSpeed();
          });
          const durationChangeHandler = () => {
            const totalSeconds = this.getTotalDurationSeconds();
            if (totalSeconds > 0) this.setScrollForDuration(totalSeconds);
          };
          this.scrollDurationMinutesInput.addEventListener(
            "input",
            durationChangeHandler
          );
          this.scrollDurationSecondsInput.addEventListener(
            "input",
            durationChangeHandler
          );

          document.addEventListener("keydown", (e) => {
            if (this.editMode === "scroll") {
              if (e.key === " ") {
                e.preventDefault();
                this.toggleScrolling();
              }
              if (e.key === "Escape") this.toggleScrollMode(false);
              return;
            }
            if ((e.ctrlKey || e.metaKey) && e.key === "z") {
              e.preventDefault();
              this.undo();
            }
            if (
              (e.ctrlKey || e.metaKey) &&
              (e.key === "y" || (e.shiftKey && e.key === "Z"))
            ) {
              e.preventDefault();
              this.redo();
            }
          });

          // *** NYTT: Lyssnare för att hantera skärmlås vid flikbyte ***
          document.addEventListener(
            "visibilitychange",
            this.handleVisibilityChange.bind(this)
          );

          this.btnInsertSection.addEventListener("click", () => {
            if (this.editMode === "scroll") return;
            const sectionType = this.sectionTypeSelect.value;
            if (sectionType) {
              this.insertSectionMarker(sectionType);
              this.recordHistoryDebounced();
              this.sectionTypeSelect.selectedIndex = 0;
            } else {
              this.showCustomAlert("Choose selection type");
            }
          });
        }

        updateModeUI() {
          if (this.editMode === "chord") {
            this.editModeLabel.textContent = "Edit (Chords)";
            this.btnToggleEditMode.textContent = "Switch to Lyrics Mode";
            if (this.mainToggleEditModeBtn) {
              this.mainToggleEditModeBtn.textContent = "C";
              this.mainToggleEditModeBtn.title = "Switch to Lyrics Mode";
            }
            this.editor.classList.remove("text-mode");
          } else if (this.editMode === "text") {
            this.editModeLabel.textContent = "Edit (Lyrics)";
            this.btnToggleEditMode.textContent = "Switch to Chord Mode";
            if (this.mainToggleEditModeBtn) {
              this.mainToggleEditModeBtn.textContent = "L";
              this.mainToggleEditModeBtn.title = "Switch to Chord Mode";
            }
            this.editor.classList.add("text-mode");
          }
        }

        // *** ÄNDRAD: toggleScrollMode hanterar nu skärmlåset ***
        toggleScrollMode(enter, startImmediately = false) {
          if (enter) {
            if (!this.editor.textContent.trim()) {
              this.showCustomAlert(
                "Lägg till text innan du startar Live Mode."
              );
              return;
            }

            // *** NY KOD: Försök skaffa skärmlåset ***
            this.acquireWakeLock();

            this.editMode = "scroll";
            this.editor.contentEditable = false;
            document.body.classList.add("scroll-mode-active");
            setTimeout(() => {
              const scrollHeight =
                this.editor.scrollHeight - this.editor.clientHeight;
              if (scrollHeight <= 0) {
                this.showCustomAlert("Texten är för kort för att scrolla.");
                this.toggleScrollMode(false); // Gå ur läget direkt
                return;
              }

              if (startImmediately) {
                this.startScrolling();
              }
            }, 100);
          } else {
            // *** NY KOD: Släpp skärmlåset ***
            this.releaseWakeLock();

            this.stopScrolling();
            this.editMode = "chord";
            this.editor.contentEditable = true;
            document.body.classList.remove("scroll-mode-active");
            this.updateModeUI();
          }
        }
        centerChordHandles() {
          this.editor.querySelectorAll(".chord").forEach((chordEl) => {
            const handle = chordEl.querySelector(".chord-handle");
            const text = chordEl.querySelector(".chord-text");
            if (handle && text) {
              const textWidth = text.offsetWidth;
              handle.style.left = `${textWidth / 2}px`;
            }
          });
        }

        // *** NYTT: Funktioner för att rendera den radiala byggaren (från din prototyp) ***
        // (Dessa ersätter renderRootNotes, renderChordTypes, och renderBassNotes)

        /**
         * Hjälpfunktion för att placera objekt i en cirkel.
         */
        positionItems(layerId, items, currentIndex, radiusMultiplier = 1) {
          const layer = document.getElementById(layerId);
          if (!layer) return; // Säkerhetskoll
          layer.innerHTML = ""; // Rensa gamla element

          const count = items.length;
          const radius = (layer.offsetWidth / 2) * radiusMultiplier;

          items.forEach((item, index) => {
            const angle = (index / count) * 2 * Math.PI - Math.PI / 2; // Vinkel i radianer, -90 grader för att starta högst upp
            const x = radius * Math.cos(angle); // Byt plats på sin/cos för att rotera
            const y = radius * Math.sin(angle);

            const div = document.createElement("div");
            div.className = "layer-item";
            let textToShow = item;
            if (item === "(root)") textToShow = "Ø";
            else if (item === "") textToShow = "Ø";
            div.textContent = textToShow;

            div.style.left = `${50 + (x / layer.offsetWidth) * 100}%`;
            div.style.top = `${50 + (y / layer.offsetHeight) * 100}%`;
            div.style.transform = "translate(-50%, -50%)";

            if (index === currentIndex) {
              div.classList.add("active");
            }

            // Klick-lyssnare för att byta val
            div.addEventListener("click", (e) => {
              e.stopPropagation(); // Förhindra att klicket går till lagret under
              this.updateRadialSelection(layerId, index);
            });

            layer.appendChild(div);
          });
        }

        /**
         * Uppdaterar state-objektet när ett val klickas.
         */
        updateRadialSelection(layerId, newIndex) {
          if (layerId === "inner-layer") {
            this.radialState.rootIndex = newIndex;
            this.radialState.root = this.musicalNotes[newIndex];
          } else if (layerId === "middle-layer") {
            this.radialState.typeIndex = newIndex;
            this.radialState.type = this.radialTypes[newIndex];
          } else if (layerId === "outer-layer") {
            this.radialState.baseIndex = newIndex;
            this.radialState.base = this.radialBassNotes[newIndex];
          }

          this.renderRadialBuilder(); // Rita om hela väljaren
        }

        /**
         * Huvudfunktion för att rita upp hela den radiala byggaren baserat på this.radialState.
         */
        renderRadialBuilder() {
          // Beräkna det aktuella ackordnamnet
          let chordName = this.radialState.root + this.radialState.type;
          if (
            this.radialState.base !== this.radialState.root &&
            this.radialState.base !== "(root)"
          ) {
            chordName += "/" + this.radialState.base; // Använder / utan mellanslag
          }

          // Uppdatera mittknappen
          document.getElementById("current-chord-display").textContent =
            chordName;

          // Rita om lagren med den nya aktiva positionen
          this.positionItems(
            "inner-layer",
            this.musicalNotes,
            this.radialState.rootIndex,
            0.85
          );
          this.positionItems(
            "middle-layer",
            this.radialTypes,
            this.radialState.typeIndex,
            0.88
          );
          this.positionItems(
            "outer-layer",
            this.radialBassNotes,
            this.radialState.baseIndex,
            0.92
          );
        }

        /**
         * Ny hjälpfunktion för att tolka ett ackord (t.ex. "Am7/C#")
         * och sätta this.radialState korrekt.
         */
        parseChordToRadialState(chordName) {
          // Regex: ^(Grundton)(Färgning)(/Baston)
          const chordRegex = /^([A-G][#b]?)([^/]*)(?:\/([A-G][#b]?))?$/;
          const parts = chordName.match(chordRegex);

          let root, type, base;

          if (parts) {
            root = parts[1];
            type = parts[2] || "";
            base = parts[3] || "(root)"; // Om ingen baston, använd '(root)'
          } else {
            // Fallback om regexen misslyckas
            root = "C";
            type = "";
            base = "(root)";
          }

          // Hitta index för varje del
          const rootIndex = this.musicalNotes.indexOf(root);
          let typeIndex = this.radialTypes.indexOf(type);
          let baseIndex = this.radialBassNotes.indexOf(base);

          // Fånga upp om de inte finns i våra listor
          if (rootIndex === -1) rootIndex = 3; // 'C'
          if (typeIndex === -1) typeIndex = 0; // '' (maj)
          if (baseIndex === -1) baseIndex = 0; // '(root)'

          // Uppdatera state
          this.radialState = {
            root: this.musicalNotes[rootIndex],
            type: this.radialTypes[typeIndex],
            base: this.radialBassNotes[baseIndex],
            rootIndex,
            typeIndex,
            baseIndex,
          };
        }

        // *** SLUT PÅ NYA FUNKTIONER FÖR RADIAL BYGGARE ***

        // *** ÄNDRAD: openChordModal använder nu den nya radiala byggaren ***
        openChordModal(element, range) {
          this.currentlyEditing = { element, range };

          if (element) {
            // Vi klickade på ett befintligt ackord.
            const existingChord = element.dataset.chord;
            // Tolka ackordet och sätt det radiala state-objektet
            this.parseChordToRadialState(existingChord);
            this.modalBtnRemove.style.display = "inline-block";
          } else if (range) {
            // Vi skapar ett nytt ackord. Återställ till C.
            this.parseChordToRadialState("C");
            this.modalBtnRemove.style.display = "none";
          }

          // Rita upp den radiala byggaren med det nya state-objektet
          this.renderRadialBuilder();

          // Visa modalen
          this.chordEditorModal.classList.add("visible");
        }

        // *** renderRootNotes, renderChordTypes, renderBassNotes är nu borttagna ***

        applyChord(chordName) {
          if (!this.currentlyEditing) return;

          if (this.currentlyEditing.element) {
            // Uppdaterar ett befintligt ackord
            const chordTextEl =
              this.currentlyEditing.element.querySelector(".chord-text");
            this.currentlyEditing.element.dataset.chord = chordName;
            if (chordTextEl) chordTextEl.textContent = chordName;
          } else if (this.currentlyEditing.range) {
            // Skapar ett nytt ackord
            const range = this.currentlyEditing.range;
            const wordText = range.toString();
            range.deleteContents();
            const chordSpan = this.createChordSpan(chordName);
            range.insertNode(chordSpan);
            const textNode = document.createTextNode(" " + wordText);
            range.setStartAfter(chordSpan);
            range.insertNode(textNode);
          }
          this.centerChordHandles();
          this.recordHistoryDebounced();
          this.closeChordModal(); // <- Stänger modalen
        }

        closeChordModal() {
          this.chordEditorModal.classList.remove("visible");
          this.currentlyEditing = null;
        }

        removeChord() {
          if (this.currentlyEditing?.element) {
            this.currentlyEditing.element.remove();
            this.recordHistoryDebounced();
          }
          this.closeChordModal();
        }

        getWordAtCursor(event) {
          try {
            const range = document.caretRangeFromPoint(
              event.clientX,
              event.clientY
            );
            if (!range || !range.startContainer.textContent) return null;
            const text = range.startContainer.textContent;
            let startIndex = range.startOffset;
            let endIndex = range.startOffset;
            while (startIndex > 0 && text[startIndex - 1].trim() !== "")
              startIndex--;
            while (endIndex < text.length && text[endIndex].trim() !== "")
              endIndex++;
            if (startIndex === endIndex) return null;
            const wordRange = document.createRange();
            wordRange.setStart(range.startContainer, startIndex);
            wordRange.setEnd(range.startContainer, endIndex);
            return wordRange;
          } catch (e) {
            return null;
          }
        }
        handleDragOver(e) {
          e.preventDefault();
          if (this.editMode !== "chord") return;
          if (e.ctrlKey || e.altKey) e.dataTransfer.dropEffect = "copy";
          else e.dataTransfer.dropEffect = "move";
          let range;
          if (document.caretRangeFromPoint)
            range = document.caretRangeFromPoint(e.clientX, e.clientY);
          else {
            const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
            if (pos) {
              range = document.createRange();
              range.setStart(pos.offsetNode, pos.offset);
            }
          }
          if (range) {
            const rect = range.getBoundingClientRect();
            this.dropIndicator.style.display = "block";
            this.dropIndicator.style.left = `${rect.left + window.scrollX}px`;
            this.dropIndicator.style.top = `${rect.top + window.scrollY}px`;
          }
        }
        handleDrop(e) {
          e.preventDefault();
          e.stopPropagation();
          this.dropIndicator.style.display = "none";
          if (this.editMode !== "chord") return;
          let range = null;
          if (document.caretRangeFromPoint)
            range = document.caretRangeFromPoint(e.clientX, e.clientY);
          else if (document.caretPositionFromPoint) {
            const pos = document.caretPositionFromPoint(e.clientX, e.clientY);
            if (pos) {
              range = document.createRange();
              range.setStart(pos.offsetNode, pos.offset);
              range.collapse(true);
            }
          }
          if (!range || !this.editor.contains(range.startContainer)) {
            range = document.createRange();
            range.selectNodeContents(this.editor);
            range.collapse(false);
          }
          let chordNode;
          if ((e.ctrlKey || e.altKey) && this.draggedChord) {
            const chordText = this.draggedChord.dataset.chord;
            chordNode = this.createChordSpan(chordText);
          } else {
            chordNode = this.draggedChord
              ? this.draggedChord
              : this.createChordSpan(e.dataTransfer.getData("text/plain"));
          }
          chordNode.style.display = "inline-block";
          range.insertNode(chordNode);
          const sel = window.getSelection();
          sel.removeAllRanges();
          const after = document.createRange();
          after.setStartAfter(chordNode);
          after.collapse(true);
          sel.addRange(after);
          this.centerChordHandles();
          this.recordHistoryDebounced();
        }
        createChordSpan(chord) {
          const span = document.createElement("span");
          span.className = "chord";
          span.dataset.chord = chord;
          span.setAttribute("contenteditable", "false");
          const chordText = document.createElement("span");
          chordText.className = "chord-text";
          chordText.textContent = chord;
          chordText.spellcheck = false;
          span.appendChild(chordText);
          const handle = document.createElement("span");
          handle.className = "chord-handle";
          handle.draggable = true;
          span.appendChild(handle);
          span.addEventListener("click", (e) => {
            if (this.editMode !== "chord" || e.target === handle) return;
            e.stopPropagation();
            this.clearChordSelection();
            span.classList.add("selected");
          });
          span.addEventListener("dblclick", (e) => {
            if (this.editMode !== "chord") return;
            e.stopPropagation();
            span.remove();
            this.recordHistoryDebounced();
          });
          handle.addEventListener("dragstart", (e) => {
            if (this.editMode !== "chord") {
              e.preventDefault();
              return;
            }
            e.stopPropagation();
            e.dataTransfer.setData("text/plain", chord);
            e.dataTransfer.effectAllowed = "copyMove";
            this.draggedChord = span;
            document.body.classList.add("is-dragging");
            if (e.dataTransfer.setDragImage) {
              const ghost = document.createElement("span");
              ghost.textContent = chord;
              ghost.style.cssText = `display:inline-block;padding:0.1em 0.4em;border-radius:3px;background-color:${getComputedStyle(
                document.body
              ).getPropertyValue("--surface")};color:${getComputedStyle(
                document.body
              ).getPropertyValue(
                "--chord-color"
              )};font-family:var(--font-sans);font-weight:600;font-size:0.85em;border:1px solid ${getComputedStyle(
                document.body
              ).getPropertyValue(
                "--border"
              )};position:absolute;top:-9999px;left:-9999px;`;
              document.body.appendChild(ghost);
              e.dataTransfer.setDragImage(ghost, 10, 15);
              setTimeout(() => document.body.removeChild(ghost), 0);
            }
            const isCopy = e.ctrlKey || e.altKey;
            if (!isCopy) {
              setTimeout(() => {
                span.style.display = "none";
              }, 0);
            }
          });
          handle.addEventListener("dragend", (e) => {
            e.stopPropagation();
            document.body.classList.remove("is-dragging");
            if (this.draggedChord && this.draggedChord.parentNode) {
              this.draggedChord.style.display = "inline-block";
            }
            this.draggedChord = null;
          });
          return span;
        }
        insertSectionMarker(type) {
          if (this.editMode === "scroll") return;
          const sel = window.getSelection();
          if (!sel.rangeCount || !this.editor.contains(sel.anchorNode))
            return this.showCustomAlert(
              "Place the marker on the row where yot want to insert the section marker."
            );
          let node = sel.anchorNode;
          while (node && node.parentNode !== this.editor)
            node = node.parentNode;
          if (!node || node.tagName !== "DIV") {
            const newDiv = document.createElement("div");
            this.editor.appendChild(newDiv);
            node = newDiv;
          }
          const existingMarker = node.querySelector(".section-marker");
          if (existingMarker) existingMarker.remove();
          this.insertSectionMarkerInDiv(node, type);
        }
        insertSectionMarkerInDiv(div, type) {
          const abbreviations = {
            Verse: "V",
            Chorus: "R",
            Stick: "S",
            Intro: "I",
            Outro: "O",
            Solo: "Solo",
            Bridge: "B",
            Dig: "M",
          };
          const markerSpan = document.createElement("span");
          markerSpan.className = "section-marker";
          markerSpan.dataset.section = type;
          markerSpan.setAttribute("contenteditable", "false");
          markerSpan.dataset.abbreviation =
            abbreviations[type] || type.charAt(0);
          const textSpan = document.createElement("span");
          textSpan.className = "section-marker-text";
          textSpan.textContent = type;
          markerSpan.appendChild(textSpan);
          div.insertBefore(markerSpan, div.firstChild);
          markerSpan.addEventListener("dblclick", (e) => {
            e.stopPropagation(); // Stoppa andra klick-händelser
            markerSpan.remove(); // Ta bort markeringen
            this.recordHistoryDebounced(); // Spara i historiken
          });
        }
        clearChordSelection() {
          this.editor
            .querySelectorAll(".chord.selected")
            .forEach((s) => s.classList.remove("selected"));
        }
        handleKeyDown(e) {
          if (this.editMode !== "chord") return;
          if (e.key === "Backspace") {
            const sel = window.getSelection();
            if (!sel.rangeCount) return;
            const range = sel.getRangeAt(0);
            if (range.collapsed && range.startOffset === 0) {
              const container = range.startContainer;
              const prev = (
                container.nodeType === Node.TEXT_NODE
                  ? container
                  : container.childNodes[range.startOffset] || null
              )?.previousSibling;
              if (
                prev &&
                prev.nodeType === Node.ELEMENT_NODE &&
                prev.classList.contains("chord")
              ) {
                e.preventDefault();
                prev.remove();
                this.recordHistoryDebounced();
              }
            }
          }
        }
        handleMutations(mutations) {
          this.stopObserver();
          mutations.forEach((mutation) => {
            if (mutation.type === "characterData")
              this.formatNode(mutation.target);
            else if (mutation.type === "childList")
              mutation.addedNodes.forEach((n) => {
                if (n.nodeType === Node.TEXT_NODE) this.formatNode(n);
              });
          });
          this.startObserver();
        }
        formatNode(node) {
          if (
            this.editMode !== "chord" ||
            !node.textContent ||
            !node.textContent.includes("[")
          )
            return;
          const text = node.textContent;
          const regex = /\[([^\]]+)\]/g;
          let match;
          const frag = document.createDocumentFragment();
          let lastIndex = 0;
          let replaced = false;
          while ((match = regex.exec(text)) !== null) {
            replaced = true;
            const beforeText = text.substring(lastIndex, match.index);
            if (beforeText)
              frag.appendChild(document.createTextNode(beforeText));
            const chord = match[1];
            const chordSpan = this.createChordSpan(chord);
            frag.appendChild(chordSpan);
            lastIndex = regex.lastIndex;
          }
          if (replaced) {
            const afterText = text.substring(lastIndex);
            if (afterText) frag.appendChild(document.createTextNode(afterText));
            if (node.parentNode) {
              const parent = node.parentNode;
              parent.replaceChild(frag, node);
              const sel = window.getSelection();
              const range = document.createRange();
              const lastNode = parent.childNodes[parent.childNodes.length - 1];
              if (lastNode) {
                range.setStart(
                  lastNode,
                  lastNode.length || lastNode.childNodes.length
                );
                range.collapse(true);
                sel.removeAllRanges();
                sel.addRange(range);
              }
              this.centerChordHandles();
            }
          }
        }
        syncChordData() {
          this.editor.querySelectorAll(".chord").forEach((chordEl) => {
            const chordTextEl = chordEl.querySelector(".chord-text");
            if (chordTextEl) chordEl.dataset.chord = chordTextEl.textContent;
          });
        }
        getContentAsText() {
          let result = [];
          this.editor.childNodes.forEach((lineDiv) => {
            let lineText = "";
            if (lineDiv.nodeType !== Node.ELEMENT_NODE) return;

            const marker = lineDiv.querySelector(".section-marker");
            if (marker) {
              lineText += `::${marker.dataset.section}::`;
            }

            lineDiv.childNodes.forEach((node) => {
              if (node.nodeType === Node.TEXT_NODE) {
                lineText += node.textContent;
              } else if (node.matches && node.matches(".chord")) {
                lineText += `[${node.dataset.chord}]`;
              }
              // *** DETTA ÄR DEN TILLAGDA DELEN ***
              else if (node.tagName === "A") {
                lineText += `[[${node.href}|${node.textContent}]]`;
              }
            });
            result.push(lineText);
          });
          return result.join("\n");
        }
        // ERSÄTT HELA DIN GAMLA loadContent-FUNKTION MED DENNA DEFINITIVA VERSION
        loadContent(text, recordHistory = false) {
          this.stopObserver();
          this.editor.innerHTML = "";
          const lines = text.split("\n");
          lines.forEach((lineText) => {
            lineText = lineText.replace(/\[\s*\]/g, "");
            const lineDiv = document.createElement("div");
            let sectionType = null;
            lineText = lineText.replace(/^::(.*?)::/, (match, type) => {
              sectionType = type;
              return "";
            });
            if (sectionType)
              this.insertSectionMarkerInDiv(lineDiv, sectionType);

            if (lineText.trim() === "" && !lineText.includes("[")) {
              lineDiv.appendChild(document.createElement("br"));
            } else {
              // -- DEN NYA, SMARTARE REGEXEN SOM LÖSER ALLT --
              // Denna regex kan nu tydligt skilja på [[Länk]] och [Ackord].
              const regex = /\[\[(.+?)(?:\|(.*?))?\]\]|\[([^\]]+)\]/g;
              let lastIndex = 0;
              let match;

              while ((match = regex.exec(lineText)) !== null) {
                // Lägg till texten som kommer före matchningen
                if (match.index > lastIndex) {
                  lineDiv.appendChild(
                    document.createTextNode(
                      lineText.substring(lastIndex, match.index)
                    )
                  );
                }

                // KOLLA OM DET ÄR EN LÄNK (grupp 1 finns) ELLER ETT ACKORD (grupp 3 finns)
                if (match[1]) {
                  // Det är en länk, t.ex. [[URL|Text]]
                  const url = match[1].trim();
                  const linkText = (match[2] || "").trim() || url; // Använd text om den finns, annars URL

                  const link = document.createElement("a");
                  link.href = url.startsWith("http") ? url : `http://${url}`; // Säkerställ http
                  link.textContent = linkText;
                  link.target = "_blank";
                  link.rel = "noopener noreferrer";
                  lineDiv.appendChild(link);
                } else if (match[3]) {
                  // Det är ett ackord, t.ex. [Am]
                  lineDiv.appendChild(this.createChordSpan(match[3]));
                }

                lastIndex = match.index + match[0].length;
              }
              // Lägg till eventuell text efter sista matchningen
              if (lastIndex < lineText.length) {
                lineDiv.appendChild(
                  document.createTextNode(lineText.substring(lastIndex))
                );
              }
            }
            this.editor.appendChild(lineDiv);
          });
          this.centerChordHandles();
          this.startObserver();
          if (recordHistory) this.recordHistory();
        }
        _transposeSingleNote(note, steps) {
          const sharpMap = { Db: "C#", Eb: "D#", Gb: "F#", Ab: "G#", Bb: "A#" };
          const match = note.match(/^([A-G](?:#|b)?)/);
          if (!match) return note;
          let rootNote = match[0];
          let normalizedNote = rootNote.includes("b")
            ? sharpMap[rootNote] || rootNote
            : rootNote;
          const currentIndex = this.musicalNotes.indexOf(normalizedNote);
          if (currentIndex !== -1) {
            const newIndex =
              (currentIndex + steps + this.musicalNotes.length) %
              this.musicalNotes.length;
            const transposedRoot = this.musicalNotes[newIndex];
            return transposedRoot + note.substring(rootNote.length);
          }
          return note;
        }
        transpose(steps) {
          if (this.editMode === "scroll") return;
          this.syncChordData();
          const text = this.getContentAsText();
          const transposedText = text.replace(
            /\[([^\]]+)\]/g,
            (fullMatch, chord) => {
              const parts = chord.split("/");
              const mainChord = parts[0];
              const bassNote = parts.length > 1 ? parts[1] : null;
              const transposedMainChord = this._transposeSingleNote(
                mainChord,
                steps
              );
              if (bassNote) {
                const transposedBassNote = this._transposeSingleNote(
                  bassNote,
                  steps
                );
                return `[${transposedMainChord}/${transposedBassNote}]`;
              } else {
                return `[${transposedMainChord}]`;
              }
            }
          );
          this.loadContent(transposedText, true);
        }
        recordHistory() {
          this.syncChordData();
          const snapshot = this.getContentAsText();
          if (this.history[this.historyIndex] === snapshot) return;
          this.history = this.history.slice(0, this.historyIndex + 1);
          this.history.push(snapshot);
          if (this.history.length > this.historyMax) this.history.shift();
          this.historyIndex = this.history.length - 1;
        }
        recordHistoryDebounced() {
          clearTimeout(this.debounceTimer);
          this.debounceTimer = setTimeout(() => this.recordHistory(), 300);
        }
        undo() {
          if (this.editMode === "scroll") return;
          if (this.historyIndex > 0) {
            this.historyIndex--;
            this.loadContent(this.history[this.historyIndex], false);
          }
        }
        redo() {
          if (this.editMode === "scroll") return;
          if (this.historyIndex < this.history.length - 1) {
            this.historyIndex++;
            this.loadContent(this.history[this.historyIndex], false);
          }
        }
        showCustomAlert(message) {
          const dialog = document.getElementById("custom-alert");
          document.getElementById("custom-alert-message").textContent = message;
          dialog.classList.add("visible");
          const okBtn = document.getElementById("custom-alert-ok");
          const close = () => dialog.classList.remove("visible");
          okBtn.onclick = close;
        }
        showCustomConfirm(message) {
          return new Promise((resolve) => {
            const dialog = document.getElementById("custom-confirm");
            document.getElementById("custom-confirm-message").textContent =
              message;
            dialog.classList.add("visible");
            const okBtn = document.getElementById("custom-confirm-ok");
            const cancelBtn = document.getElementById("custom-confirm-cancel");
            const close = (value) => {
              dialog.classList.remove("visible");
              resolve(value);
            };
            okBtn.onclick = () => close(true);
            cancelBtn.onclick = () => close(false);
          });
        }
        toggleDarkMode() {
          document.body.classList.toggle("dark-mode");
          const isDarkMode = document.body.classList.contains("dark-mode");
          localStorage.setItem(
            StableChordEditor.STORAGE_KEYS.DARK_MODE,
            isDarkMode ? "enabled" : "disabled"
          );
          this.btnToggleDarkMode.textContent = isDarkMode ? "☀️" : "🌙";
        }
        createNewProject() {
          this.titleInput.value = "";
          this.authorInput.value = "";
          this.loadContent(
            'Open the side panel, name your project then choose "Project" and save..Now you can replace this text whith your lyrics and chords...',
            true
          );
          this.projectList.selectedIndex = 0;
          localStorage.removeItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT);
          if (this.fontSizeSlider) {
            this.fontSizeSlider.value = 16;
          }
          this.editor.style.fontSize = "16px";
          this.titleInput.focus();
        }
        saveProject(name) {
          this.syncChordData();
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          projects[name] = {
            title: this.titleInput.value,
            author: this.authorInput.value,
            fontSize: this.editor.style.fontSize || "16px",
            content: this.getContentAsText(),
            scrollSpeed: this.scrollSpeed,
            duration: this.getTotalDurationSeconds(),
          };
          localStorage.setItem(
            StableChordEditor.STORAGE_KEYS.PROJECTS,
            JSON.stringify(projects)
          );
          localStorage.setItem(
            StableChordEditor.STORAGE_KEYS.LAST_PROJECT,
            name
          );
          this.updateProjectList(name);
          const originalText = this.btnSaveProject.textContent;
          this.btnSaveProject.textContent = "Saved";
          this.btnSaveProject.disabled = true;
          setTimeout(() => {
            this.btnSaveProject.textContent = "Save";
            this.btnSaveProject.disabled = false;
          }, 1200);
        }
        loadProject(name) {
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          if (projects[name]) {
            const data = projects[name];
            this.titleInput.value = data.title || "";
            this.authorInput.value = data.author || "";
            this.editor.style.fontSize = data.fontSize || "16px";
            if (this.fontSizeSlider) {
              const num = parseInt((data.fontSize || "").replace("px", ""));
              if (!isNaN(num)) this.fontSizeSlider.value = num;
            }
            this.loadContent(data.content || "", true);

            if (data.scrollSpeed !== undefined) {
              const sliderVal =
                ((data.scrollSpeed - this.MIN_MOVE_SPEED) /
                  (this.MAX_MOVE_SPEED - this.MIN_MOVE_SPEED)) *
                100;
              this.scrollSpeedSlider.value = Math.max(
                0,
                Math.min(100, Math.round(sliderVal))
              );
              this.setScrollSpeed(this.scrollSpeedSlider.value);
            } else {
              this.scrollSpeedSlider.value = 20;
              this.setScrollSpeed(20);
            }

            if (data.duration !== undefined) {
              this.updateDurationInputs(data.duration);
            } else {
              this.updateDurationFromSpeed();
            }

            localStorage.setItem(
              StableChordEditor.STORAGE_KEYS.LAST_PROJECT,
              name
            );
            if (this.projectList.value !== name) this.projectList.value = name;
          }
        }
        loadLastProject() {
          this.updateProjectList();
          const last = localStorage.getItem(
            StableChordEditor.STORAGE_KEYS.LAST_PROJECT
          );
          if (last) this.loadProject(last);
          else
            this.loadContent(
              "Welcome to ProChorder!\nIf this is your first time with ProChorder, please use the ?-button in the top menu.",
              true
            );
        }
        updateProjectList(selectedValue) {
          const list = this.projectList;
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          const currentProjects = Object.keys(projects).sort();
          list.innerHTML = '<option value="">Load project...</option>';
          currentProjects.forEach((name) => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            list.appendChild(option);
          });
          const last =
            selectedValue ||
            localStorage.getItem(StableChordEditor.STORAGE_KEYS.LAST_PROJECT);
          if (last && currentProjects.includes(last)) list.value = last;
        }
        deleteProject(name) {
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          delete projects[name];
          localStorage.setItem(
            StableChordEditor.STORAGE_KEYS.PROJECTS,
            JSON.stringify(projects)
          );
          const last = localStorage.getItem(
            StableChordEditor.STORAGE_KEYS.LAST_PROJECT
          );
          if (last === name) {
            localStorage.removeItem(
              StableChordEditor.STORAGE_KEYS.LAST_PROJECT
            );
            this.createNewProject();
          }
          this.updateProjectList();
          this.showCustomAlert(`Project "${name}" Removed.`);
        }
        async deleteAllProjects() {
          if (
            await this.showCustomConfirm(
              "Are you sure? This erase ALL songs permanently."
            )
          ) {
            localStorage.removeItem(StableChordEditor.STORAGE_KEYS.PROJECTS);
            localStorage.removeItem(
              StableChordEditor.STORAGE_KEYS.LAST_PROJECT
            );
            this.updateProjectList();
            this.createNewProject();
            this.showCustomAlert("All projects are removed.");
          }
        }
        async renameProject(oldName, newName) {
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          if (projects[oldName] && !projects[newName]) {
            projects[newName] = projects[oldName];
            projects[newName].title = newName;
            delete projects[oldName];
            localStorage.setItem(
              StableChordEditor.STORAGE_KEYS.PROJECTS,
              JSON.stringify(projects)
            );
            const lastProject = localStorage.getItem(
              StableChordEditor.STORAGE_KEYS.LAST_PROJECT
            );
            if (lastProject === oldName)
              localStorage.setItem(
                StableChordEditor.STORAGE_KEYS.LAST_PROJECT,
                newName
              );
            this.titleInput.value = newName;
            this.updateProjectList(newName);
            this.showCustomAlert(`This project is now renamed "${newName}".`);
          } else if (projects[newName]) {
            this.showCustomAlert(
              `A project called "${newName}" already exist.`
            );
          }
        }
        generatePdfForProject(projectData) {
          const { jsPDF } = window.jspdf;
          const doc = new jsPDF();
          let y = 20;
          const margin = 15;
          const baseFontSizePx = parseInt(
            (projectData.fontSize || "16px").replace("px", ""),
            10
          );
          const baseFontSizePt = baseFontSizePx * 0.75;
          const lyricLineHeightMultiplier = 0.7;
          const LYRIC_LINE_HEIGHT = baseFontSizePt * lyricLineHeightMultiplier;
          const SECTION_HEADER_LINE_HEIGHT = baseFontSizePt * 0.9;
          const CHORD_COLOR = "#0052cc";
          const TEXT_COLOR = "#172b4d";
          const CHORD_OFFSET = baseFontSizePt * 0.3;
          doc.setFont("helvetica", "bold");
          doc.setFontSize(18);
          doc.text(projectData.title || "Song Title", 105, y, {
            align: "center",
          });
          y += 8;
          doc.setFont("helvetica", "normal");
          doc.setFontSize(12);
          doc.text(projectData.author || "Artist", 105, y, { align: "center" });
          y += 15;
          const lines = (projectData.content || "").split("\n");
          lines.forEach((lineText) => {
            let sectionType = null;
            let remainingText = lineText.replace(
              /^::(.*?)::/,
              (match, type) => {
                sectionType = type;
                return "";
              }
            );
            if (sectionType) {
              if (y > 280) {
                doc.addPage();
                y = 20;
              }
              if (y > 25) y += SECTION_HEADER_LINE_HEIGHT * 0.5;
              doc.setFont("helvetica", "bold");
              doc.setFontSize(baseFontSizePt * 1.1);
              doc.setTextColor(TEXT_COLOR);
              doc.text(sectionType, margin, y);
              y += SECTION_HEADER_LINE_HEIGHT;
            }
            if (remainingText.trim()) {
              if (y > 280) {
                doc.addPage();
                y = 20;
              }
              const parts = remainingText
                .split(/(\[[^\]]+\])/g)
                .filter((p) => p);
              let currentX = margin;
              parts.forEach((part) => {
                if (part.startsWith("[") && part.endsWith("]")) {
                  const chord = part.substring(1, part.length - 1);
                  doc.setFont("helvetica", "bold");
                  doc.setFontSize(baseFontSizePt * 0.85);
                  doc.setTextColor(CHORD_COLOR);
                  doc.text(chord, currentX, y - CHORD_OFFSET);
                } else {
                  doc.setFont("helvetica", "normal");
                  doc.setFontSize(baseFontSizePt);
                  doc.setTextColor(TEXT_COLOR);
                  doc.text(part, currentX, y);
                  currentX += doc.getTextWidth(part);
                }
              });
              y += LYRIC_LINE_HEIGHT;
            } else if (!sectionType) {
              y += LYRIC_LINE_HEIGHT * 0.7;
            }
          });
          return doc.output("blob");
        }
        exportPdf() {
          this.syncChordData();
          const projectData = {
            title: this.titleInput.value,
            author: this.authorInput.value,
            content: this.getContentAsText(),
            fontSize: this.editor.style.fontSize,
          };
          const pdfBlob = this.generatePdfForProject(projectData);
          saveAs(pdfBlob, `${this.sanitizeFilename(projectData.title)}.pdf`);
        }
        exportTxt() {
          this.syncChordData();
          const title = this.titleInput.value;
          const author = this.authorInput.value;
          const content = this.getContentAsText();
          const fullText = `${title}\n${author}\n\n${content}`;
          const blob = new Blob([fullText], {
            type: "text/plain;charset=utf-8",
          });
          saveAs(blob, `${this.sanitizeFilename(title)}.txt`);
        }
        async exportAllAsZip() {
          this.btnExportZip.textContent = "Genererar...";
          this.btnExportZip.disabled = true;
          try {
            const projects =
              JSON.parse(
                localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
              ) || {};
            if (Object.keys(projects).length === 0)
              return this.showCustomAlert("No project to export.");
            const zip = new JSZip();
            for (const key in projects) {
              const project = projects[key];
              const pdfBlob = this.generatePdfForProject(project);
              zip.file(`${this.sanitizeFilename(project.title)}.pdf`, pdfBlob);
            }
            const content = await zip.generateAsync({ type: "blob" });
            saveAs(content, "alla-låtar.zip");
          } catch (e) {
            this.showCustomAlert("Fel vid ZIP-export.");
          } finally {
            this.btnExportZip.textContent = "ZIP";
            this.btnExportZip.disabled = false;
          }
        }
        exportJson() {
          this.syncChordData();
          const projectData = {
            title: this.titleInput.value,
            author: this.authorInput.value,
            content: this.getContentAsText(),
            fontSize: this.editor.style.fontSize,
            scrollSpeed: this.scrollSpeed,
            duration: this.getTotalDurationSeconds(),
          };
          const blob = new Blob([JSON.stringify(projectData, null, 2)], {
            type: "application/json",
          });
          saveAs(blob, `${this.sanitizeFilename(projectData.title)}.json`);
        }
        exportAllJson() {
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          // Convert the object of projects into an array of projects
          const projectsArray = Object.values(projects);
          const blob = new Blob([JSON.stringify(projectsArray, null, 2)], {
            type: "application/json",
          });
          saveAs(blob, `songs-backup.json`);
        }
        importJsonFromFile(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = async (e) => {
            try {
              const data = JSON.parse(e.target.result);
              if (Array.isArray(data)) {
                if (
                  await this.showCustomConfirm(
                    `${data.length} låtar hittades. Vill du importera? Existerande låtar med samma titel skrivs över.`
                  )
                )
                  this.importMultipleProjects(data);
              } else if (data.title) {
                this.importSingleProject(data);
              }
            } catch (e) {
              this.showCustomAlert("Fel vid import av JSON.");
            }
          };
          reader.readAsText(file);
        }
        async importJsonFromUrl(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) throw new Error("Network response was not ok");
            const data = await response.json();
            if (Array.isArray(data)) this.importMultipleProjects(data);
            else if (data.title) this.importSingleProject(data);
          } catch (e) {
            this.showCustomAlert("Fel vid import från URL.");
          }
        }
        importSingleProject(data) {
          this.titleInput.value = data.title || "";
          this.authorInput.value = data.author || "";
          this.editor.style.fontSize = data.fontSize || "16px";
          this.loadContent(data.content || "", true);
          if (data.scrollSpeed) this.scrollSpeed = data.scrollSpeed;
          if (data.duration) this.updateDurationInputs(data.duration);
          this.saveProject(data.title);
        }
        importMultipleProjects(projectsArray) {
          const projects =
            JSON.parse(
              localStorage.getItem(StableChordEditor.STORAGE_KEYS.PROJECTS)
            ) || {};
          let importedCount = 0,
            overwrittenCount = 0;
          for (const project of projectsArray) {
            if (project && project.title) {
              if (projects[project.title]) overwrittenCount++;
              else importedCount++;
              projects[project.title] = project;
            }
          }
          localStorage.setItem(
            StableChordEditor.STORAGE_KEYS.PROJECTS,
            JSON.stringify(projects)
          );
          this.updateProjectList();
          this.showCustomAlert(
            `${importedCount} nya låtar importerades. ${overwrittenCount} låtar uppdaterades.`
          );
          if (projectsArray.length > 0)
            this.loadProject(projectsArray[0].title);
        }
        sanitizeFilename(name) {
          return name.replace(/[\/\\?%*:|"<>]/g, "-") || "låt";
        }
        toggleScrolling() {
          if (this.scrollInterval) this.stopScrolling();
          else this.startScrolling();
        }

        startScrolling() {
          if (this.scrollInterval) return;

          if (this.scrollSpeed <= 0) {
            this.calculateAndSetScrollSpeed();
          }

          if (this.scrollSpeed <= 0) {
            return;
          }

          this.scrollBtnPlayPause.textContent = "❚❚";
          this.scrollRemainder = 0;

          const scroll = () => {
            this.scrollRemainder += this.scrollSpeed;
            const move = Math.floor(this.scrollRemainder);

            if (move > 0) {
              this.editor.scrollTop += move;
              this.scrollRemainder -= move;
            }

            if (
              this.editor.scrollTop + this.editor.clientHeight >=
              this.editor.scrollHeight
            ) {
              this.stopScrolling();
            } else {
              this.scrollInterval = requestAnimationFrame(scroll);
            }
          };
          this.scrollInterval = requestAnimationFrame(scroll);
        }

        stopScrolling() {
          if (this.scrollInterval) cancelAnimationFrame(this.scrollInterval);
          this.scrollInterval = null;
          this.scrollBtnPlayPause.textContent = "▶";
        }
        setScrollSpeed(value) {
          const val = parseFloat(value);
          if (val === 0) {
            this.scrollSpeed = 0;
            return;
          }
          this.scrollSpeed =
            this.MIN_MOVE_SPEED +
            (val / 100) * (this.MAX_MOVE_SPEED - this.MIN_MOVE_SPEED);
        }
        getTotalDurationSeconds() {
          const minutes = parseInt(this.scrollDurationMinutesInput.value) || 0;
          const seconds = parseInt(this.scrollDurationSecondsInput.value) || 0;
          return minutes * 60 + seconds;
        }
        updateDurationInputs(totalSeconds) {
          if (totalSeconds > 0) {
            this.scrollDurationMinutesInput.value = Math.floor(
              totalSeconds / 60
            );
            this.scrollDurationSecondsInput.value = totalSeconds % 60;
          } else {
            this.scrollDurationMinutesInput.value = 4;
            this.scrollDurationSecondsInput.value = 0;
          }
        }
        setScrollForDuration(durationSeconds) {
          setTimeout(() => {
            const scrollHeight = Math.max(
              1,
              this.editor.scrollHeight - this.editor.clientHeight
            );
            if (scrollHeight <= 0) return;
            const frames = Math.max(1, durationSeconds * 60);
            this.scrollSpeed = scrollHeight / frames;
            const percent = Math.round(
              ((this.scrollSpeed - 0.02) / (0.5 - 0.02)) * 100
            );
            this.scrollSpeedSlider.value = Math.max(0, Math.min(100, percent));
          }, 100);
        }
        updateDurationFromSpeed() {
          if (this.scrollSpeed < 0.001) return;
          const scrollHeight = Math.max(
            1,
            this.editor.scrollHeight - this.editor.clientHeight
          );
          if (scrollHeight <= 0) return;
          const durationSeconds = scrollHeight / (this.scrollSpeed * 60);
          this.updateDurationInputs(Math.round(durationSeconds));
        }
      }

      window.addEventListener("load", () => new StableChordEditor("editor"));
    </script>

    <button id="floating-live-btn" title="Starta Live-läge">▶</button>
  </body>
</html>
